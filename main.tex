\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage[parfill]{parskip}
\usepackage{hyperref}
\usepackage{extarrows}
\usepackage{centernot}
\usepackage{mathtools}
\usepackage{braket}
\usepackage{mathpartir}
\usepackage{listings}
\usepackage{zi4}
\usepackage{mdframed}
\usepackage{minted}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{empheq}
\input{macros.tex}
\begin{document}

\title{DFLAMIO: Distributed FLAM in LIO}

\author{\IEEEauthorblockN{Name}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address}
}

\maketitle

\begin{abstract}
We present a natural application of the FLAM authorization logic: A programming language with dynamic information-flow control. The language is constructed by instantiating the abstract label model of LIO with the model offered by FLAM. The resulting system, FLAMIO, has provably strong confidentiality and integrity guarantees, and allows for a straightforward extension of LIO that supports distributed computation. Specifically, we extend FLAMIO with remote procedure calls, which in turn can be used to implement the distributed part of the authorization logic of FLAM. We have implemented \lang and shown that it enforces a strong notion of noninterference. We also present several case studies demonstrating the usefulness of having dynamic information-flow in a distributed setting with mutual distrust.
\end{abstract}

%\begin{IEEEkeywords}
%component, formatting, style, styling, insert
%\end{IEEEkeywords}

\section{Introduction}
Talk about why FLAC and DFLAC do not use the full expressivity of FLAM (purely static guarantees).

\section{Background}

Introduce \cite{Arden:2015:FA:2859845.2859998} and \cite{SRMMlio}. Talk about the the syntax in Figure~\ref{fig:flam-syntax}.

\begin{figure}[h]
    \centering
    \begin{tabular}{ll}
    $n \in \Nameset$ \\
    $p ::= \bot \mid \top \mid \name \mid p \conj p \mid p \disj p \mid \conf{p} \mid \integ{p} \mid \owner{p}{p}$
    \end{tabular}
    \caption{Syntax of FLAM}
    \label{fig:flam-syntax}
\end{figure}

\section{A calculus for \lang}\label{lab:calculus}
Figure~\ref{fig:language-syntax} shows the syntax of \lang. The shaded regions describe syntax not part of the surface language, but rather constructs used during evaluation.

\begin{figure*}
    \centering
    \begin{tabular}{l}
         $\val ::= \true \mid \false \mid () \mid p \mid \addr \mid x \mid \abs{n}{\lb{p}{\type}}{x}{\expr} \mid (\expr, \expr) \mid \cons{\expr}{\expr} \mid \nil \mid \graybox{\lb{p}{\expr}} \mid \graybox{\lio{\expr}}$ \\
         $\begin{aligned}[t]
         \expr ::=&\;\; \val \mid \app{\expr}{\expr} \mid \proj{i}{\expr} \mid \ifexpr{\expr}{\expr}{\expr} \mid \case{\expr}{\expr}{\expr} \mid \fix{\expr} \mid \return{\expr} \mid \bind{\expr}{\expr} \\ &\mid
         \new{\expr}{\expr} \mid \readref{\expr} \mid \writeref{\expr}{\expr} \mid \Label{\expr}{\expr} \mid \unlabel{\expr} \mid
         \tolabeled{\expr}{\expr} \mid \getlabel \\ &\mid \getclearance \mid \labelof{\expr} \mid \withscope{\expr} \mid \withstrategy{\expr}{\expr} \\ &\mid \adddelegate{\expr}{\expr}{\expr} \mid \removedelegate{\expr}{\expr}{\expr} \mid \getstrategy \mid \expr \actsfor \expr \\ &\mid
         \graybox{\wait{n}[\type]} \mid \graybox{\resetstrategy{\overline{p}}{\expr}} \mid \graybox{\resetTolabeled{p}{q}{\expr}} \mid \graybox{\resetscope{\scope}{\expr}}
         \end{aligned}$ \\
         %$\overline{\expr} ::= \expr; \overline{\expr} \mid \termsym$ \\
         $\type ::= \bool \mid \unit \mid \func{\type}{\type} \mid \listtype{\type} \mid \pair{\type}{\type} \mid \labeltype \mid \labeled{\type} \mid \liotype{\type} \mid \reftype[n]{\type}$ \\
    \end{tabular}
    \caption{The \lang{} language}
    \label{fig:language-syntax}
\end{figure*}

Talk about:
\begin{enumerate}
    \item The grammar
    \item The evaluation context
    \item The local reduction rules
    \item Discuss the usage of strategies
    \item The global reduction rules
    \item The type system
    \item Show preservation
    \item Talk about the invariant used for preservation?
\end{enumerate}

\section{Security guarantees}
Talk about:
\begin{enumerate}
    \item Traces
    \item Define knowledge
    \item Define TINI
    \item Show the TINI statement
\end{enumerate}

\section{Implementation and case studies}
We have implemented \lang as a library in Haskell. The code is approximately 2200 lines of code and uses the efficient query resolution algorithm for authorization queries described in \cite{Arden:2015:FA:2859845.2859998}, along with additional layers of caching to avoid repeated network communication. To simplify the implementation we differ from the calculus in that an RPC invocation does not send the function across the network. Instead, the receiver of the RPC has a table mapping identifiers to functions, and the caller sends this identifier along with the list of arguments. This does not lead to loss of expressivity, though: As shown in \cite{Cooper:2009:RC:1599410.1599439} one can translate a program written in the calculus from Section~\ref{lab:calculus} to a program written in Haskell using the \lang implementation by performing defunctionalization.

Using this implementation we have constructed three use cases for \lang. The first use case is a distributed bank, in which users can perform RPCs to handle transactions across accounts between different users. The second use case is a social jukebox service \cite{Lots of citations} where people can schedule music during social gatherings. The third use case is a secure database containing confidential information about government agencies.

\subsection{Secure banking}
We first consider a secure banking service $S$. For simplicity we assume the language has been extended with numbers and strings. A user is represented by a named principal $n$, and each user has an account consisting of a single nonnegative number representing their balance. A user authenticates themselves by invoking the function $\mathtt{login}$ which received the user, a labeled string representing the password, and a callback to invoke if the authentication succeeds. Furthermore, we assume a primitive $\mathtt{transfer}$ for transferring money between two accounts. The signatures of these functions is given in Figure~\ref{fig:sec-banking-sigs}.
Using these primitive we can model several complex scenarios. For instance in Figure~\ref{fig:sec-bank-alice-send-to-bob}, Alice authenticates with the bank and sends Bob 100 dollars. Since this will reveal to Bob the fact that Alice has at least 100 dollars on her account, she needs to add a delegation stating that Bob is allowed to learn this information. This delegation is controlled by Alice and Alice allows the presence of this delegation to be learned only by herself and Bob. This decision is reflected by the label placed on the delegation.

\begin{figure}
    \centering
    \begin{align*}
\mathtt{login}&: \labeltype \to \labeled{\mathtt{String}} \\ &\quad \to \liotype{\unit} \to \liotype{\unit}\\
\mathtt{transfer}&: \labeltype \to \labeltype \to \Integer \to \liotype{\unit}
\end{align*}
    \caption{Primitives for implementing secure banking.}
    \label{fig:sec-banking-sigs}
\end{figure}

\TODO{The labeling of the password requires conf(A) actsfor conf(S), meaning that Alice should be able to read the server's secrets in order to label the password such that only the server can see the value. This seems overly restrictive.}

\begin{figure}
    \centering
\begin{lstlisting}
((*@$\lambda^{\text{A}}$@*) _ .
  pw <- label "password" ((*@$\conf{$S$} \conj \integ{$ A$}$@*))
  login A pw
    (withScope
      assume (*@$\conf{$B$}$@*) (*@$\actsfor$@*) (*@$\conf{$A$}$@*) @ ((*@$\conf{$(A $ \disj $ B)$} \conj \integ{$ A$}$@*))
      transfer Alice Bob 100)) ()
\end{lstlisting}
\caption{Alice authenticates with the server and sends money to Bob.}
\label{fig:sec-bank-alice-send-to-bob}
\end{figure}

\BRAINDUMP{
Idea: The bank is a shared resource where clients can invoke RPCs to perform transactions.
Interface for the bank:
\begin{enumerate}
    \item \textsf{transfer: Principal $\rightarrow$ Principal $\rightarrow$ LIO Unit}
    \item \textsf{login: Principal $\rightarrow$ Labeled String $\rightarrow$ LIO Unit $\rightarrow$ LIO Unit} where the Labeled String argument represents password
\end{enumerate}
Use cases:
\begin{enumerate}
    \item Alice can transfer to Bob if Bob is allowed to see the amount of money on Alice's account (as accounts cannot be negative), and Bob has given Alice integrity permissions so that she can write to Bob's account. \TODO{This last requirement is bad: Now Alice can transfer money from Bob's account to her own.}
    \item Alice can allow her accountant, Charlie, to move money on her behalf for a limited time using $\mathsf{newScope}$ and $\mathsf{addDelegate}$.
\end{enumerate}}

\subsection{A secure social jukebox service}
We now consider a secure version of a social jukebox service. A group of principals $\Nameset$ is gathered at a party and want to perform confidential voting about which songs should be played at the party. We assume a distinguished principal $\mathsf{J}$ (for jukebox) representing a machine supporting the following primitive functions.
\begin{align*}
\mathtt{vote}&: \labeled{\String} \rightarrow \liotype{\unit}\\
\mathtt{candidates}&: \unit \rightarrow \liotype{\listtype{\pair{\String}{\listtype{\labeled{\labeltype}}}}}\\
\mathtt{play}&: \String \rightarrow \liotype{\unit}
\end{align*}
The function $\mathtt{vote}$ casts a vote for the song represented by the labeled string argument.

\BRAINDUMP{
Idea: Friends are gathered at a party, but they want to vote on which songs should be played. But we don't want people to know who votes for what. So there should be a principal $\mathsf{Jukebox}$ that can read a value containing votes, and this value can be updated by party principals using an RPC call.}

\BRAINDUMP{We should not allow a user to vote twice on the same song, so we need to keep a mapping from songs to which principals have voted on this song. But party members should not be allowed to read who votes for what! (We don't want people to know I votes for Taylor Swift).}

\BRAINDUMP{Interface for the social jukebox:
\begin{enumerate}
    \item \textsf{vote: Song $\rightarrow$ LIO Unit}
    \item \textsf{addCandidate: Song $\rightarrow$ LIO ()}
    \item \textsf{getCandidates: LIO [(String, [Labeled Principal])]}
    \item \textsf{playSong: Song $\rightarrow$ LIO Unit}
\end{enumerate}
Note that now one can implement a function \textsf{hasVoted: Principal $\rightarrow$ Song $\rightarrow$ LIO Bool} that uses \textsf{getCandidates}.}

\subsection{Government agency records}
\BRAINDUMP{
Idea: We want to keep a record of Principals and the agencies they belong to, along with their clearance levels. This is easy: A delegation (Alice ``acts for'' CIA:secret$\rightarrow$) represents the fact that Alice is allowed to read CIA information at level secret. We can then check permissions by just doing an ``acts for'' check. But as we want these delegations to be secret (ie., we don't want the public to know that Alice works for CIA and has secret clearance) we can put in a sufficiently high label on the delegation:
Alice ``acts for'' CIA:secret$\rightarrow$ @ CIA:secret. Now only principals with clearance above CIA:secret can know if Alice is a member of CIA and has clearance secret.
Now the CIA can (on their servers) add this delegation, and other agents ``in the field'' can do a query and check Alice's permissions.}

\section{Related work}
DFLATE, CLIO and Concurrent LIO, Narita's work on abstraction machine for RPC, Myers' Hyperflow.

\section{Conclusion}

\bibliographystyle{abbrv}
\bibliography{litterature}

\vspace{12pt}

\end{document}
