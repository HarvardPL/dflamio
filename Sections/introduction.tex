Most modern systems require some form of authorization to control access to data \cite{Menezes:1996:HAC:548089}. Such authorization mechanisms tend to be complex and hard to get right, even though the correctness of such components is vital for the security of the system and its users \cite{Ferraiolo:1999:RAC:300830.300834}. 
The behavior of such systems is often very dynamic, with access control constantly changing on a per-user basis. Thus, the authorization mechanisms used in these systems also need to be very dynamic and able to securely control changes to user privileges \cite{Ferraiolo:1999:RAC:300830.300834} at run time. Furthermore, the mere existence of a trust relationship between two principals may leak confidential information to an attacker if the trust relationship was established based on the result of a confidential computation. Dually, if attackers can provide trust relationships that influences otherwise high integrity computations they may be able to influence access control decisions.

These issues are especially ubiquitous in distributed systems, where machines often do not agree on the trust relationship among principals. Yet, agreement on whether to allow a user access to new information or allow a user to modify already existing information in the system, needs to be established.

The Flow-Limited Authorization Model (FLAM) \cite{Arden:2015:FA:2859845.2859998} is an expressive security model designed for rigorous reasoning about dynamic changes to authorization policies in a distributed setting, where nodes can forward trust checking requests to other nodes in the system. FLAM guarantees that no confidential information is leaked to an attacker through the trust checking mechanism. This makes FLAM ideal for highly dynamic security policies involving many principals with intricate trust relationships. However, currently no programming language that builds on top of FLAM reaps the full benefit of the authorization logic.

In this paper we introduce \lang{}, which takes a coarse-grained approach to information-flow control. Coarse-grained IFC differs from fine-grained IFC (as seen in information-flow aware languages like FlowCaml \cite{???} and Jif \cite{???}) by not labeling individual values with security labels, but instead labels the \emph{computational context} in which the program is running by a single label. Coarse-grained IFC lends itself naturally to dynamic enforcement techniques as demonstrated by its success in both operating systems \cite{Zeldovich:2006:MIF:1267308.1267327, Zeldovich:2008:SDS:1387589.1387610} and programming languages \cite{SRMMlio, Buiras:2015:HMS:2784731.2784758}.

We show that FLAM's rules for proving trust relationships has a straightforward encoding in the coarse-grained IFC setting of \lang. As evidence of this we implement \lang{} as a Haskell library that encapsulates FLAM's proof search in an information-flow aware computational context, which ensures that the proof search does not leak confidential information to, and cannot be influenced by, attackers. \lang{} supports distributed proof search of trust, where nodes forward trust checking to other nodes in the system.

%FLAM has been used to build the Flow-Limited Authorization Calculus (FLAC) \cite{7536372}, which uses the FLAM principal lattice to reason about declassification. Unfortunately, FLAC does not make full use of the judgment for deciding trust in FLAM. For instance, the rule for deciding trust by forwarding trust queries to other nodes in a distributed system is missing. Furthermore, the noninterference result presented in \cite{7536372} is based on a static type-system, further limiting the use of the dynamic mechanisms offered by FLAM.

%We show how the FLAM judgment for deciding distributed trust relationships between principals can be build on top of LIO. The formal security guarantees offered by LIO ensures that deciding FLAM trust relationships at runtime does not leak any confidential information. We call this new language \lang.

In summary, the contributions of this paper are the following:
\begin{itemize}
    \item We show how the FLAM principal lattice integrates cleanly into a coarse-grained information-flow control setting.
    \item We use FLAM to extend LIO to a distributed setting.
    \item We present a formal model of \lang{} and prove that the language guarantees noninterference.
    \item We present an implementation of \lang{} as a Haskell library, along with an efficient implementation of the FLAM authorization logic for deciding trust relationships.
    \item We present several examples of distributed information-flow problems which can easily be modeled using \lang.
\end{itemize}

The rest of the paper is structured as follows. Section~\ref{sec:background} introduces the necessary concepts from FLAM and LIO, and Section~\ref{sec:programming} demonstrates how \lang{} combines FLAM and LIO through several examples. Section~\ref{sec:calculus} describes the formal calculus for \lang{} and how the FLAM judgment for deciding trust relations is modeled in a coarse-grained setting. Section~\ref{sec:guarantees} defines the attacker model we consider in this work, and presents the formal security guarantees offered by \lang. Section~\ref{sec:case-studies} discusses the implementation in Haskell and presents three case studies demonstrating the use of \lang. Section~\ref{sec:related-work} presents related work and Section~\ref{sec:conclusion} concludes.