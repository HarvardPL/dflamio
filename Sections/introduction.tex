Most modern systems require some form of authorization to control access to data \cite{Menezes:1996:HAC:548089}. Such authorization mechanisms tend to be complex and hard to get right, even though the correctness of such components is vital for the security of the system and its users \cite{Ferraiolo:1999:RAC:300830.300834}. 
The behavior of such systems is often dynamic, with access control continually changing on a per-user basis. Thus, the authorization mechanisms used in these systems also need to be dynamic and able to securely control changes to user privileges \cite{Ferraiolo:1999:RAC:300830.300834} at runtime. Furthermore, the mere existence of a trust relationship between two principals may leak confidential information to an attacker if the trust relationship was established based on the result of a confidential computation. Dually, if attackers can provide trust relationships that influence otherwise high-integrity computations, they may be able to inappropriately influence access control decisions. These issues are especially ubiquitous in distributed systems, where nodes often do not agree on the trust relationship among principals.

The Flow-Limited Authorization Model (FLAM) \cite{Arden:2015:FA:2859845.2859998} is an expressive security model designed for rigorous reasoning about dynamic changes to authorization policies in a distributed setting, where nodes can forward trust checking requests to other nodes in the system. FLAM also guarantees that no confidential information is leaked to an attacker through the trust checking mechanism. This makes FLAM ideal for highly dynamic security policies involving many principals with intricate trust relationships. However, currently no programming language that builds on top of FLAM reaps the full benefit of the authorization logic.

In this paper we introduce \lang{}, which takes a coarse-grained approach to information-flow control (IFC). Fine-grained IFC (as seen in information-flow aware languages like FlowCaml \cite{Pottier:2003:IFI:596980.596983} and Jif \cite{Myers:1999:JPM:292540.292561}) labels individual values with security labels. By contrast, coarse-grained IFC does not label individual values, but instead labels the \emph{computational context} in which the program is running with a single label. Coarse-grained IFC lends itself naturally to dynamic enforcement techniques as demonstrated by its success in both operating systems \cite{Zeldovich:2006:MIF:1267308.1267327, Zeldovich:2008:SDS:1387589.1387610, Efstathopoulos:2005:LEP:1095810.1095813, Krohn:2007:IFC:1294261.1294293} and programming languages \cite{SRMMlio, Buiras:2015:HMS:2784731.2784758, Stefan:2012:ACT:2364527.2364557, Buiras:2015:DED:2786558.2786563}.

We show that FLAM's rules for proving trust relationships have a straightforward encoding in the coarse-grained IFC setting of \lang{}, which is inspired by the work on Labeled IO (LIO) \cite{SRMMlio}. As evidence of the straightforward encoding, we implement \lang{} as a Haskell library \cite{flamiolib} that encapsulates FLAM's proof search for trust relationships in an information-flow aware computational context, which ensures that the proof search itself does not leak confidential information to, and cannot be inappropriately influenced by, attackers. Leveraging FLAM's decentralized authorization model, \lang{} supports distributed proof search of trust relationships, where nodes can forward trust checking to other nodes in the system. To demonstrate the usefulness of having distributed proof search of trust relationships in a setting with dynamic security policies we present three case studies involving distributed computations with confidential information and mutually distrusting principals that must cooperate to perform their tasks.

The case studies also demonstrate a novel technique for mitigating the problem of \emph{label creep} during proof search, which traditionally is associated with coarse-grained information-flow \cite{SRMMlio}. Label creep refers to the label of the computational context \emph{creeping} up the information-flow lattice as the program executes. We present a technique that gives the programmer fine-grained control over the way proofs of trust are derived, and how the proofs can affect the label on the computational context.

We also present a calculus for \lang{}, which formally proves that \lang{} enforces a noninterference-based \cite{6234468} security property guaranteeing that attackers cannot leak or corrupt information, despite the incorporation of FLAM as an expressive dynamic mechanism to state and reason about trust relationships.

This paper makes the following contributions.
\begin{itemize}
    \item We show how the FLAM principal lattice integrates cleanly into a language with coarse-grained information-flow control and distributed trust checking.
    \item We present a formal model of \lang{} and prove that the language guarantees noninterference.
    \item We present an implementation of \lang{} as a Haskell library, along with an efficient implementation of the FLAM authorization logic for deciding trust relationships.
    \item We describe a novel approach to avoid the problem of \emph{label creep} during proof search normally associated with coarse-grained IFC.
    \item We present several examples of distributed information-flow problems all of which can easily be modeled using \lang.
\end{itemize}

The rest of the paper is structured as follows. Section~\ref{sec:background} introduces the necessary concepts from FLAM and LIO, and Section~\ref{sec:programming} demonstrates how \lang{} combines FLAM and LIO through several examples. Section~\ref{sec:calculus} describes the formal calculus for \lang{} and how the FLAM judgment for deciding trust relations is modeled in a coarse-grained setting. Section~\ref{sec:guarantees} defines the attacker model we consider in this work and presents the formal security guarantees offered by \lang. Section~\ref{sec:case-studies} discusses the implementation in Haskell and presents three case studies demonstrating the use of \lang. Section~\ref{sec:related-work} presents related work and Section~\ref{sec:conclusion} concludes.