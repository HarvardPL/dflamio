Most modern systems require some form of authorization to control access to data \cite{Menezes:1996:HAC:548089}. Such authorization mechanisms tend to be complex and hard to get right, even though the correctness of such components is vital for the security of the system and its users \cite{Ferraiolo:1999:RAC:300830.300834}. 
The behavior of such systems is often very dynamic, with access control constantly changing on a per-user basis. Thus, the authorization mechanisms used in these systems also need to be very dynamic and able to securely control changes to user privileges \cite{Ferraiolo:1999:RAC:300830.300834} at run time. Furthermore, the mere existence of a trust relationship between two principals may leak confidential information to an attacker if the trust relationship was established based on the result of a confidential computation. Dually, if attackers can provide trust relationships that influences otherwise high integrity computations they may be able to influence access control decisions.

These issues are especially ubiquitous in distributed systems, where machines often do not agree on the trust relationship among principals. Yet, agreement on whether to allow a user access to new information or allow a user to modify already existing information in the system, needs to be established.

The Flow-Limited Authorization Model (FLAM) \cite{Arden:2015:FA:2859845.2859998} is an expressive security model designed for rigorous reasoning about dynamic changes to authorization policies in a distributed setting, where nodes can forward trust checking requests to other nodes in the system. FLAM guarantees that no confidential information is leaked to an attacker through the trust checking mechanism. This makes FLAM ideal for highly dynamic security policies involving many principals with intricate trust relationships. However, currently no programming language that builds on top of FLAM reaps the full benefit of the authorization logic.

In this paper we introduce \lang{}, which takes a coarse-grained approach to information-flow control. Coarse-grained IFC differs from fine-grained IFC (as seen in information-flow aware languages like FlowCaml \cite{Pottier:2003:IFI:596980.596983} and Jif \cite{Myers:1999:JPM:292540.292561}) by not labeling individual values with security labels, but instead labels the \emph{computational context} in which the program is running by a single label. Coarse-grained IFC lends itself naturally to dynamic enforcement techniques as demonstrated by its success in both operating systems \cite{Zeldovich:2006:MIF:1267308.1267327, Zeldovich:2008:SDS:1387589.1387610, Efstathopoulos:2005:LEP:1095810.1095813, Krohn:2007:IFC:1294261.1294293} and programming languages \cite{SRMMlio, Buiras:2015:HMS:2784731.2784758, Stefan:2012:ACT:2364527.2364557, Buiras:2015:DED:2786558.2786563}.

We show that FLAM's rules for proving trust relationships has a straightforward encoding in the coarse-grained IFC setting of \lang{}, which is inspired by the work on Labeled IO (LIO) \cite{SRMMlio}. As evidence of the straightforward encoding, we implement \lang{} as a Haskell library that encapsulates FLAM's proof search in an information-flow aware computational context, which ensures that the proof search does not leak confidential information to, and cannot be influenced by, attackers. \lang{} supports distributed proof search of trust, where nodes can forward trust checking to other nodes in the system. To demonstrate the usefulness of having distributed proof search of trust in a setting with very dynamic security policies we present three case studies involving distributed computations with confidential information and mutually distrusting principals that must cooperate to perform their tasks.

The case studies also demonstrate a novel technique for mitigating the problem of \emph{label creep}, which traditionally is associated with coarse-grained information flow. Label creep refers to the label of the computational context \emph{creeping} up the information-flow lattice as the program executes. We present a technique that gives the programmer fine-grained control over the way proofs of trust are derived, and how the proofs can affect the label on the computational context.

We also present a calculus for \lang{}, which formally proves that \lang{} enforces a noninterference-based \cite{6234468} security property guaranteeing that attackers cannot leak or corrupt information.

This paper makes the following contributions.
\begin{itemize}
    \item We show how the FLAM principal lattice integrates cleanly into a coarse-grained information-flow control setting with distributed trust checking.
    \item We present a formal model of \lang{} and prove that the language guarantees noninterference.
    \item We present an implementation of \lang{} as a Haskell library, along with an efficient implementation of the FLAM authorization logic for deciding trust relationships.
    \item We describe a novel approach for avoiding the problem of \emph{label creep} normally associated with coarse-grained IFC.
    \item We present several examples of distributed information-flow problems which can easily be modeled using \lang.
\end{itemize}

The rest of the paper is structured as follows. Section~\ref{sec:background} introduces the necessary concepts from FLAM and LIO, and Section~\ref{sec:programming} demonstrates how \lang{} combines FLAM and LIO through several examples. Section~\ref{sec:calculus} describes the formal calculus for \lang{} and how the FLAM judgment for deciding trust relations is modeled in a coarse-grained setting. Section~\ref{sec:guarantees} defines the attacker model we consider in this work, and presents the formal security guarantees offered by \lang. Section~\ref{sec:case-studies} discusses the implementation in Haskell and presents three case studies demonstrating the use of \lang. Section~\ref{sec:related-work} presents related work and Section~\ref{sec:conclusion} concludes.