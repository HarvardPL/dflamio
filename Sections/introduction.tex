Most modern systems require some form of authorization to control access to data \cite{Menezes:1996:HAC:548089}. Such authorization mechanisms tend to be complex and hard to get right, even though the correctness of such components is vital for the security of the system and its users \cite{Ferraiolo:1999:RAC:300830.300834}. The behavior of such systems is often very dynamic, with access control constantly changing on a per-user basis. Thus, the authorization mechanisms used in such systems also need to be very dynamic and able to securely control runtime changes to user privileges \cite{Ferraiolo:1999:RAC:300830.300834}.
This is especially true for distributed systems. In this case, machines located geographically far away from each other, and thus not always up-to-date on the latest trust relationships between users or between users and the system, need to agree on whether to allow a user access to new information or allow a user to modify already existing information in the system.

A common correctness guarantee for the security of such systems is noninterference \cite{6234468}. Noninterference states that an attacker only learns what a given policy is allowing them to learn, or dually that an attacker only influences the part of the system that the policy is allowing them to influence. Such strong guarantees is rarely possible in real systems, where release of confidential information can be necessary. For instance, when a user inputs an invalid username and password pair, the system must respond with an appropriate message, allowing an attacker to learn that such a user does not exist in the system. In such cases a \emph{declassification} of confidential information is necessary. Dually, systems sometimes need to allow untrusted information to influence the result of a trusted computation. For instance during an auction, where untrusted bidders each submit an untrusted bid and the system determines the winner based on the untrusted bid. This is an example of an \emph{endorsement}. The general term for such examples is information \emph{downgrading}\footnote{\emph{Down} refers to the direction of flow in the information-flow lattice.}.

Several works \cite{Efstathopoulos:2005:LEP:1095810.1095813, Krohn:2007:IFC:1294261.1294293, Arden:2015:FA:2859845.2859998, Hicks05dynamicupdating} propose solutions to the problem of enforcing security in the presence of downgrading. The Flow-Limited Authorization Model (FLAM) \cite{Arden:2015:FA:2859845.2859998} is especially appealing as the judgment which proves distributed trust relationships is shown to not leak confidential information, and allows for rigorous reasoning about dynamic changes to authorization policies.

FLAM has been used to build the Flow-Limited Authorization Calculus (FLAC) \cite{7536372}, which uses the FLAM principal lattice to reason about declassification. Unfortunately, FLAC does not make full use of the judgment for deciding trust in FLAM. For instance, the rule for deciding trust by forwarding trust queries to other nodes in a distributed system is missing. Furthermore, the noninterference result presented in \cite{7536372} is based on a static type-system, further limiting the use of the dynamic mechanisms offered by FLAM.

In this work we build an enforcement of dynamic information-flow policies on top of the FLAM principal lattice. A popular language-based technique for dynamic information-flow is Labeled IO (LIO) \cite{SRMMlio}. LIO is a Haskell-library for coarse-grained information-flow control (IFC) and uses a \emph{floating-label} approach for dynamic IFC where a single label protects the computational context.

We show how the FLAM judgment for deciding distributed trust relationships between principals can be build on top of LIO. The formal security guarantees offered by LIO ensures that deciding FLAM trust relationships at runtime does not leak any confidential information. We call this new language \lang.

In summary, the contributions of this paper are the following:
\begin{itemize}
    \item We show how the FLAM principal lattice integrates cleanly into a coarse-grained information-flow control setting.
    \item We use FLAM to extend LIO to a distributed setting.
    \item We present a formal model of \lang{} and prove that the language guarantees noninterference.
    \item We present an implementation of \lang{} as a Haskell library, along with an efficient implementation of the FLAM authorization logic for deciding trust relationships.
    \item We present several examples of distributed information-flow problems which can easily be modeled using \lang.
\end{itemize}

The rest of the paper is structured as follows. Section~\ref{sec:background} introduces the necessary concepts from FLAM and LIO. Section~\ref{sec:calculus} describes the formal calculus for \lang{} and how the FLAM judgment for deciding trust relations is modeled in a coarse-grained setting. Section~\ref{sec:guarantees} defines the attacker model we consider in this work, and presents the formal security guarantees offered by \lang. Section~\ref{sec:case-studies} discusses the implementation in Haskell and presents three case studies demonstrating the use of \lang. Section~\ref{sec:related-work} presents related work and finally Section~\ref{sec:conclusion} concludes.