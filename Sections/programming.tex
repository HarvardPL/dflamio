In this section we informally introduce \lang{} and the concepts needed to combine LIO and FLAM. Section~\ref{sec:calculus} will then formalize the intuitions presented in this section. We proceed by demonstrating the usefulness of \lang{}\ in the context of a secure, decentralized banking application, which we also discuss in Section~\ref{sec:case-studies}. The intended security policy of the bank is that a user $u$ can transfer money from an account only if the owner of the account trusts $u$.

\lang{} incorporates FLAM into LIO by using the FLAM principal lattice $(\mathcal{P}, \flowsto)$ as the label model of LIO. As FLAM unifies principals and labels, this also allows \lang{} to also reason about trust relationships between principals using the trust lattice $(\mathcal{P}, \actsfor)$.
Given a named principal $n \in \Nameset$ (e.g., Alice or Bob) we call $n$ a \emph{node} when referring to the machine that executes code on $n$'s behalf. We assume each named principal has a corresponding machine executing code on its behalf. Initially, the current label of node $n$ is $\conf{\bot} \wedge\, \integ{n}$ and its clearance label is $\conf{n} \wedge \integ{\bot}$.\footnote{We follow previous conventions \cite{Arden:2015:FA:2859845.2859998} and omit projections of the $\bot$ principal in the remainder of the paper.} The initial current label states that the node has not observed any sensitive information, and that $\integ{n}$ is the most trusted the node can be. Dually, the clearance label states that $\conf{n}$ is an upper bound on the confidentiality of the information $n$ is permitted to observe, and that its integrity is permitted to be affected by any information. We discuss two important aspects of \lang: Cross node communication using remote procedure calls (RPC), and distributed proof search of trust relationships.

\subsection{Remote Procedure Calls}
Nodes in \lang{} communicate by remote invocation of functions on different machines, and functions are thus annotated with the node on which they should be evaluated. That is, the application $\app{(\abs{n}{p}{x}{\expr})}{\expr'}$ denotes applying a function $\abs{n}{p}{x}{\expr}$ located on machine $n$ to an argument $\expr'$, and the returned value is labeled with principal $p$. The label serves a purpose similar to $\tolabeledkw$, where labeling the value helps mitigate label creep by delaying the effect of raising the current label until the value is needed.

Consider a login function for an online banking service. The function
\begin{lstlisting}
login = (*@$\lambda^{\mathsf{bank}}_{\integ{\mathsf{bank}}}$@*) u p . if checkCredentials u p
                        then return u else return (*@$\bot$@*)
\end{lstlisting}
is evaluated on the node $\mathsf{bank}$, and returns a principal labeled with the integrity of the bank, which represents an access token. The expression \lstinline[mathescape]!login Alice "password"! evaluates to a value $\mathsf{Alice}$ labeled with the principal $\integ{\mathsf{bank}}$ if Alice's password is ``password'', and $\bot$ labeled with $\integ{\mathsf{bank}}$ otherwise. As the principal $\integ{\mathsf{Alice}}$ (i.e., the current label of node $\mathsf{Alice}$) does not satisfy $\integ{\mathsf{Alice}} \flowsto \integ{\mathsf{bank}}$, Alice cannot grant herself access because the semantics does not allow her to label values with the principal $\integ{\mathsf{bank}}$.
However, Alice can unlabel the returned access token, as it holds that $\integ{\mathsf{bank}} \flowsto \conf{\mathsf{Alice}}$ (i.e., the clearance label of node Alice). So while Alice cannot forge new access tokens, she is free to inspect whether the token grants her access to the bank.

\subsection{Proof search}
In many practical scenarios, proving trust relationships of the form $p \actsfor q$ requires distributed knowledge spread across multiple nodes. In this section, we will see examples of this, as well as how distributed proof search of trust relationships in \lang{} is implemented. The three most important aspects of the proof search are using delegations, managing delegations using \emph{strategies} and forwarding trust checking to other nodes. After discussing these concepts, we apply them in the context of the decentralized banking application. We keep the discussion informal and defer precise formulations of the concepts until in Section~\ref{sec:calculus}.

\paragraph{Delegations}
A delegation is of the form $\lb{r}{p \actsfor q}$ (pronounced $r$ \emph{says that} $p$ \emph{acts for} $q$); we call $r$ the label of the delegation, or say that the delegation is labeled with principal $r$, and we call $p \actsfor q$ the body of the delegation. The terminology is the result of delegations being implemented as a pairs $(p, q)$ labeled with $r$ in \lang, and are subject to similar runtime checks. Thus both the confidentiality (i.e., who can observe the presence of the delegation), and the integrity (i.e., who can modify the delegation) is captured by $r$. In particular, a delegation can be used by a proof search on a node $n$ when $r \flowsto \conf{n}$. This requirement enforces the policy that the label of the delegation flows to the clearance of node $n$, meaning that $n$ can observe only the presence of delegations whose label flows to $n$'s clearance label.

\paragraph{Strategies}
As delegations are implemented as labeled values, using a delegation in a proof search raises the current label by the label of the delegation, similar to how LIO unlabels labeled values. This makes fine-grained control of how delegations are used important to avoid unnecessary label creep. One approach to such control could be to always unlabel all delegations whose label flows to the clearance label of the node performing the proof search. This would be correct (i.e., if a delegation that proves the query is present it is found) and secure (i.e., because only delegations whose label flows to the node's clearance label are unlabeled), but it will most likely raise the current label unnecessarily. In particular, if a delegation is examined, the current label must be raised, even if the delegation is not ultimately used in the proof. Thus if a node has a delegation labeled with a very restrictive label, then all proof searches could be tainted by that label.
An alternative approach would be to design algorithms that unlabels just the right delegations to prove the query. However, as delegations are labeled values, the body of the delegation cannot be inspected without unlabeling the value and raising the current label. So an algorithm has to decide whether to unlabel a delegation by inspecting only the label of the delegation and not its body.

For these reasons \lang{} uses \emph{strategies}, which are lists of principals, to specify which delegations are used in a proof, and in which order. For instance, if the delegation $\lb{r}{p \actsfor q}$ is stored on a node that evaluates the expression \lstinline[mathescape]!withStrategy [s, r, t] (p $\actsfor$ q)! the node will first search for delegations with a label that flows to $s$. Assuming we cannot prove the query $p \actsfor q$ using only these delegations, then delegations with a label that flows to $r$ is used, and the delegation $\lb{r}{p \actsfor q}$ can now be used to complete the proof search. This example demonstrates how programmers can use strategies to control how \lang{} performs fine-grained proof search with specialized strategies for handling delegations. The choice of which strategy to use is application specific, but a reasonable default strategy is $[\mathsf{cur}, \mathsf{clr}]$, where $\mathsf{cur}$ and $\mathsf{clr}$ are the current label and clearance labels of the node respectively.

\paragraph{Forwarding}
In \lang{}, nodes can forward trust checks to other nodes that might have local information (i.e., delegations) about particular trust relationships. Forwarding queries is straightforward as a query $p \actsfor q$ is simply a monadic expression returning a boolean, and such a query can be forwarded to other nodes in \lang{} using remote procedure calls.
A node $n$ can forward trust checking to a node $m$ only if $n$'s current label flows to $\conf{m}$ (i.e., the clearance of $m$). This restriction ensures that $m$ is allowed to learn about the information that caused $n$ to initiate the query.  The following snippet demonstrates how a leak can be constructed without the check:
\begin{lstlisting}
(*@$\lambda^{\mathsf{alice}}_{\conf{\mathsf{alice}}}$@*) _ . do h <- unlabel aliceSecret
               if h then (*@$p \actsfor q$@*) else return 0
\end{lstlisting}
If $\mathsf{aliceSecret}$ is labeled with $\conf{\mathsf{Alice}}$, the unlabel operation will raise the current label $\level_{\mathsf{cur}}$ to $\level_{\mathsf{cur}} \join \conf{\mathsf{Alice}}$ tracking the fact that control flow depends on information at level at most $\level_{\mathsf{cur}} \join \conf{\mathsf{Alice}}$. Upon forwarding the query $p \actsfor q$ to another node $m$, Alice reveals that $\mathsf{aliceSecret}$ contained a non-zero value. Checking that Alice's current label flows to $\conf{m}$ ensures that $m$ is allowed to learn this information.

Returning to the secure banking application, consider the implementation in Figure~\ref{fig:sec-transfer} of $\mathsf{transfer}$ that transfers $n$ dollars from user $u_\mathsf{from}$ to $u_\mathsf{to}$ using access token $\mathsf{tok}$.

\begin{figure}
\centering
\begin{lstlisting}
transfer = (*@$\lambda^{\mathsf{bank}}_{\bot}$@*) tok (*@$\mathsf{u}_\mathsf{from}$@*) (*@$\mathsf{u}_\mathsf{to}$@*) n . do
              u <- unlabel tok
              withStrategy [(*@$\conf{\mathsf{bank}} \conj \integ{\mathsf{u}_{\mathsf{from}}}$@*)]
                (if u (*@$\actsfor$@*) (*@$\mathsf{u}_\mathsf{from}$@*) then transfer# (*@$\mathsf{u}_\mathsf{from}$@*) (*@$\mathsf{u}_\mathsf{to}$@*) n
                 else return ())
\end{lstlisting}
\caption{Secure transfer of $n$ dollars from $u_{\mathsf{from}}$ to $u_{\mathsf{to}}$ using access token $\mathsf{tok}$.}
\label{fig:sec-transfer}
\end{figure}

First, the access token $\mathsf{tok}$ acquired by $\mathsf{login}$ is unlabeled, revealing the identity of the caller. Then, a check is done to ensure that the caller can act on behalf of the user from which money is being transferred. For this example the bank requires the trust relationship to be observable by the bank, and having integrity of the principal from which the money is transferred, which is reflected in the strategy specifying that only delegations at level $\conf{\mathsf{bank}} \conj \integ{\mathsf{u}_{\mathsf{from}}}$ or below (i.e., weaker secrecy and stronger integrity) are used. Finally, a primitive function $\mathsf{transfer\#}$ performs the actual transfer of money, and if the trust relationship cannot be established the function returns a unit value. Figure~\ref{fig:bob-transfer-from-alice} demonstrates how Bob can transfer money from Alice if she grants Bob the appropriate trust. First, Alice adds a delegation specifying that Bob can act on behalf of Alice, and that this information has the integrity of Alice. Then, Bob performs an RPC to the $\mathtt{login}$ function, which returns an access token. Finally, he transfers 50 dollars from Alice's account to his own account. Note that the use of the strategy $[\conf{\mathsf{bank}} \conj \integ{\mathsf{u}_{\mathsf{from}}}]$ in $\mathtt{transfer}$ ensures not only that the bank only uses delegations it is allowed to observe, but also that the bank does not use a delegation provided by an inappropriate principal such as Bob, as Bob cannot add a delegation labeled with the principal $\integ{\mathsf{Alice}}$.

\begin{figure}
\centering
\begin{lstlisting}
(*@$\lambda^{\mathsf{alice}}_{\bot}$@*) _ . do assume bob (*@$\actsfor$@*) alice @ (*@$\integ{\mathsf{alice}}$@*)
              ((*@$\lambda^{\mathsf{bob}}_{\bot}$@*) _ . do tok <- login bob "password"
                           transfer tok alice bob 50) ()
\end{lstlisting}
\caption{Alice grants Bob access to perform transfers on her behalf.}
\label{fig:bob-transfer-from-alice}
\end{figure}