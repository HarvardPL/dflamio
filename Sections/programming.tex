In this section we informally introduce \lang{} and the concepts needed to combine LIO and FLAM. Section~\ref{sec:calculus} will then formalize the intuitions presented in this section. We proceed by demonstrating the usefulness of \lang{}\ in the context of a secure, decentralized banking application, which we also discuss in Section~\ref{sec:case-studies}.

\lang{} incorporates FLAM into LIO by using the FLAM principal lattice as the label model of LIO.
Given a named principal $n \in \Nameset$ (e.g., Alice or Bob) we call $n$ a \emph{node} when referring to the machine that executes code on $n$'s behalf. We assume each named principal has a corresponding machine executing code on its behalf. Initially, the current label of node $n$ is $\conf{\bot} \wedge \integ{n}$ and the clearance label is $\conf{n} \wedge \integ{\bot}$.\footnote{We follow previous conventions \cite{Arden:2015:FA:2859845.2859998} and omit projections of the $\bot$ principal in the remainder of the paper.} The initial current label represents the fact that the node has observed no information, and no information has affected the integrity of the node. The clearance specifies that $n$ can only observe information labeled with a label that flows to $n$ and that $n$ can access information independently of its integrity. We discuss two important aspects of \lang: Cross node communication using remote procedure calls (RPC), and distributed proof search of trust relationships.

\subsection{Remote Procedure Calls}
Nodes in \lang{} communicate by remote invocation of functions on different machines, and functions are thus annotated with the node on which they should be evaluated. That is, the application $\app{(\abs{n}{p}{x}{\expr})}{\expr'}$ denotes applying an argument $\expr'$ to a function $\abs{n}{p}{x}{\expr}$ located on machine $n$ and the returned term is labeled with principal $p$. The label serves a purpose similar to $\tolabeledkw$, where labeling the value helps mitigate label creep by delaying the effect of raising the current label until the value is needed.

Consider a login function for an online banking service. The function
\begin{lstlisting}
login = (*@$\lambda^{\mathsf{bank}}_{\integ{\mathsf{bank}}}$@*) u p . if checkCredentials u p
                        then return u else return (*@$\bot$@*)
\end{lstlisting}
is evaluated on a node $\mathsf{bank}$, and returns a principal labeled with the integrity of the bank, which represents an access token. The expression \lstinline[mathescape]!login Alice "password"! evaluates to a labeled principal $\mathsf{Alice}$ if Alice's password is ``password'', and $\bot$ otherwise. As the principal $\integ{\mathsf{Alice}}$ (i.e., the current label of node $\mathsf{Alice}$) does not satisfy $\integ{\mathsf{Alice}} \flowsto \integ{\mathsf{bank}}$ Alice cannot grant herself access as the semantics does not allow her to label values with the principal $\integ{\mathsf{bank}}$.
However, Alice can unlabel the returned access token, as it holds that $\integ{\mathsf{bank}} \flowsto \conf{\mathsf{Alice}}$ (i.e., the clearance label of node Alice). So while Alice cannot forge new access tokens, she is free to inspect whether the token grants her access to the bank.

\subsection{Proof search}
In many practical scenarios, proving trust relationships of the form $p \actsfor q$ requires distributed knowledge spread across multiple nodes. In this section, we will see examples of this, as well as how distributed proof search of trust relationships in \lang{} is implemented. The three most important aspects of the proof search are using delegations, managing delegations using \emph{strategies} and forwarding trust checking to other nodes. After discussing these concepts, we apply them in the context of the decentralized banking application. We keep the discussion informal and defer precise formulations of the concepts until in Section~\ref{sec:calculus}.

\paragraph{Delegations}
A delegation is of the form $\lb{r}{p \actsfor q}$ (pronounced $r$ \emph{says that} $p$ \emph{acts for} $q$), and we call $r$ the label of the delegation, or say that the delegation is labeled with principal $r$, and we call $p \actsfor q$ the body of the delegation. The terminology stems from the fact that delegations are implemented as labeled pairs in \lang, and are subject to similar runtime checks. In particular, a delegation can be used by a proof search on a node $n$ when $r \flowsto \conf{n}$. This requirement enforces the policy that the label of the delegation flows to the clearance of node $n$, meaning that $n$ can observe only the presence of delegations whose label flows to $n$'s clearance label.

\paragraph{Strategies}
As delegations are implemented as labeled values in LIO, using a delegation in a proof search raises the current label by the label of the delegation, similar to how LIO unlabels labeled values. This makes fine-grained control of how delegations are used important to avoid unnecessary label creep.
One approach to such control could be to always unlabel all delegations whose flow to the clearance label of the node performing the proof search. This would be correct (i.e., if a delegation that proves the query is present it is found) and secure (i.e., because only delegations whose label flows to the node's clearance label is unlabeled), but it will most likely raise the current label unnecessarily assuming that not all delegations are needed for each query to be proved.
An alternative approach would be to design algorithms that unlabels just the right amount of delegations to satisfy the query. However, as delegations are implemented using labeled values, no computation other than unlabeling them is possible, and so it is impossible to observe the body of the delegation before it is unlabeled and the current label is already raised. So an algorithm has to decide whether to unlabel a delegation by inspecting only the label of the delegation, making clever algorithm design difficult.

For these reasons \lang{} uses \emph{strategies}, which are lists of principals, to specify which delegations are used in a proof, and in which order. For instance, if the delegation $\lb{r}{p \actsfor q}$ is stored on node $n$ and $n$ is evaluating the expression \lstinline[mathescape]!withStrategy [s, r, t] (p $\actsfor$ q)! the node will first search for delegations with a label that flows to $s$. Assuming no delegations that satisfy this proves the query, delegations with a label that flows to $r$ is used, and the delegation $\lb{r}{p \actsfor q}$ can now be used to complete the proof search. This example demonstrates how \lang{} performs fine-grained proof search with specialized strategies for handling delegations, giving the programmer the ability to securely minimize label creep by taking advantage of domain-specific knowledge about a particular application.

\paragraph{Forwarding}
In \lang{} nodes can forward trust checks to other nodes that might have local information (i.e., delegations) about particular trust relationships. Forwarding queries is straightforward as $p \actsfor q$ is simply a monadic expression returning a boolean, and such a query can be forwarded to other nodes in \lang{} using remote procedure calls.
A node $n$ can forward trust checking to a node $m$ only if $n$'s current label flows to $\conf{m}$. This restriction ensures that $m$ is allowed to learn about the information that caused $n$ to initiate the query. Figure~\ref{fig:leak-via-forward} demonstrates how a leak can be constructed without the check. If $\mathsf{aliceSecret}$ is labeled with $\conf{\mathsf{Alice}}$, the unlabel operation will raise the current label $\level_{\mathsf{cur}}$ to $\level_{\mathsf{cur}} \join \conf{\mathsf{Alice}}$ tracking the fact that control flow depends on information at level at most $\level_{\mathsf{cur}} \join \conf{\mathsf{Alice}}$. Upon forwarding the query $p \actsfor q$ to another node $m$, Alice reveals that $\mathsf{aliceSecret}$ contained a non-zero value. Checking that Alice's current label flows to $\conf{m}$ ensures that $m$ is allowed to learn this information.

\begin{figure}
    \centering
    \begin{lstlisting}
    ((*@$\lambda^{\mathsf{alice}}_{\botinfoflow}$@*) _ . do h <- unlabel aliceSecret
                   if h then (*@$p \actsfor q$@*) else return 0) ()
    \end{lstlisting}
    \caption{Opportunity for leaking the value of $\mathsf{aliceSecret}$ using a trust relationship query without the information-flow check.}
    \label{fig:leak-via-forward}
\end{figure}

Returning to the secure banking application, consider an implementation of $\mathsf{transfer}$ that transfers $n$ dollars from user $u_\mathsf{from}$ to $u_\mathsf{to}$ using access token $\mathsf{tok}$.

\begin{lstlisting}
transfer = (*@$\lambda^{\mathsf{bank}}_{\botinfoflow}$@*) tok (*@$\mathsf{u}_\mathsf{from}$@*) (*@$\mathsf{u}_\mathsf{to}$@*) n . do
              u <- unlabel tok
              withStrategy [(*@$\integ{\mathsf{u}_{\mathsf{from}}}$@*)]
                (if u (*@$\actsfor$@*) (*@$\mathsf{u}_\mathsf{from}$@*) then transfer# (*@$\mathsf{u}_\mathsf{from}$@*) (*@$\mathsf{u}_\mathsf{to}$@*) n
                 else return ())
\end{lstlisting}

First, the access token $\mathsf{tok}$ acquired by $\mathsf{login}$ is unlabeled, revealing the identity of the caller. Then, a check is done to ensure that the caller can act on behalf of the user from which money is being transferred. For this example the bank requires the trust relationship to be public information, and that the trust relationship has the integrity of the principal from which the money is transferred, which is reflected in the strategy specifying that only delegations at level $\integ{\mathsf{u}_{\mathsf{from}}}$ or below are used. Finally, a primitive function $\mathsf{transfer\#}$ performs the actual transferring of money, and if the trust relationship cannot be established the function returns a unit value. Figure~\ref{fig:bob-transfer-from-alice} demonstrates how Bob can transfer money from Alice if she grants Bob the appropriate trust. First, Alice adds a delegation specifying that Bob can act on behalf of Alice, and that this information has the integrity of Alice. Then, Bob performs an RPC to the $\mathtt{login}$ function, which returns an access token. Finally, he transfers 50 dollars from Alice's account to his own account. Note that the use of the strategy $[\integ{\mathsf{u}_{\mathsf{from}}}]$ in $\mathtt{transfer}$ ensures that the bank does not use a delegation provided by Bob, as Bob cannot add a delegation labeled $\integ{\mathsf{Alice}}$ or higher.

\begin{figure}
\centering
\begin{lstlisting}
(*@$\lambda^{\mathsf{alice}}_{\botinfoflow}$@*) _ . do assume bob (*@$\actsfor$@*) alice @ (*@$\integ{\mathsf{alice}}$@*)
              (*@$\lambda^{\mathsf{bob}}_{\botinfoflow}$@*) _ . do tok <- login bob "password"
                           transfer tok alice bob 50
\end{lstlisting}
\caption{Alice grants Bob access to perform transfers on her behalf.}
\label{fig:bob-transfer-from-alice}
\end{figure}