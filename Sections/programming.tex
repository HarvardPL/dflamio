In this section we informally introduce \lang{} and the concepts needed to combine LIO and FLAM. Section~\ref{sec:calculus} will then formalize the intuitions presented in this section. We proceed by demonstrating the usefulness of \lang{}\ in the context of a secure, decentralized banking application, which we also discuss in Section~\ref{sec:case-studies}. The intended security policy of the bank is that a user $u$ can transfer money from an account only if the owner of the account trusts $u$.

\lang{} incorporates FLAM into LIO by using the FLAM information-flow lattice $(\mathcal{P}, \flowsto)$ as the label model of LIO. As FLAM unifies principals and labels, this allows \lang{} to also reason about trust relationships between principals using the trust lattice $(\mathcal{P}, \actsfor)$.
Given a named principal $n \in \Nameset$ (e.g., Alice or Bob) we call $n$ a \emph{node} when referring to the machine that executes code on $n$'s behalf. We assume each named principal has a corresponding machine executing code on its behalf. Initially, the current label of node $n$ is $\conf{\bot} \wedge\, \integ{n}$ and its clearance label is $\conf{n} \wedge \integ{\bot}$.\footnote{We follow previous conventions \cite{Arden:2015:FA:2859845.2859998} and omit projections of the $\bot$ principal in the remainder of the paper.} The initial current label states that the node has not observed any sensitive information and that $\integ{n}$ is the most trusted the node can be. Dually, the clearance label states that $\conf{n}$ is an upper bound on the confidentiality of the information $n$ is permitted to observe and that its integrity is permitted to be affected by any information. We discuss two important aspects of \lang: Cross node communication using remote procedure calls (RPC), and distributed proof search of trust relationships.

\subsection{Remote Procedure Calls}
Nodes in \lang{} communicate by remote invocation of functions on different machines, and functions are thus annotated with the node on which they should be evaluated. That is, the application $\app{(\abs{n}{p}{x}{\expr})}{\expr'}$ denotes applying a function $\abs{n}{p}{x}{\expr}$ located on machine $n$ to an argument $\expr'$, and the returned value is labeled with principal $p$. The label serves a purpose similar to $\tolabeledkw$, where labeling the value helps mitigate label creep by delaying the effect of raising the current label until the value is needed.

Consider a login function for an online banking service. The function
\begin{lstlisting}
login = (*@$\lambda^{\mathsf{bank}}_{\integ{\mathsf{bank}}}$@*) u p . if checkCredentials u p
                        then return u else return (*@$\bot$@*)
\end{lstlisting}
is evaluated on the node $\mathsf{bank}$, and returns a principal labeled with the integrity of the bank, which represents an access token. The expression \lstinline[mathescape]!login Alice "password"! evaluates to a value $\mathsf{Alice}$ labeled with the principal $\integ{\mathsf{bank}}$ if Alice's password is ``password'', and $\bot$ labeled with $\integ{\mathsf{bank}}$ otherwise. As the principal $\integ{\mathsf{Alice}}$ (i.e., the current label of node $\mathsf{Alice}$) does not satisfy $\integ{\mathsf{Alice}} \flowsto \integ{\mathsf{bank}}$, Alice cannot grant herself access because the semantics does not allow her to label values with the principal $\integ{\mathsf{bank}}$.
However, Alice can unlabel the returned access token, as it holds that $\integ{\mathsf{bank}} \flowsto \conf{\mathsf{Alice}}$ (i.e., the clearance label of node Alice). So while Alice cannot forge new access tokens, she is free to inspect whether the token grants her access to the bank.

\subsection{Proof search}
In many practical scenarios, proving trust relationships of the form $p \actsfor q$ requires distributed knowledge spread across multiple nodes. In this section, we will see examples of this, as well as how distributed proof search of trust relationships in \lang{} is implemented. The three most important aspects of the proof search are using delegations, managing delegations using \emph{strategies} and forwarding trust checking to other nodes. After discussing these concepts, we apply them in the context of the decentralized banking application. We keep the discussion informal and defer precise formulations of the concepts until Section~\ref{sec:calculus}.

\paragraph{Delegations}
A delegation is of the form $\lb{r}{p \actsfor q}$ (pronounced $r$ \emph{says that} $p$ \emph{acts for} $q$); we call $r$ the label of the delegation, or say that the delegation is labeled with principal $r$, and we call $p \actsfor q$ the body of the delegation. The terminology is the result of delegations being implemented in {\lang} as pairs $(p, q)$ labeled with $r$, and are subject to similar runtime checks. Thus both the confidentiality (i.e., who can observe the presence of the delegation) and the integrity (i.e., who influenced the delegation) are captured by $r$. In particular, a delegation can be used by a proof search on a node $n$ when $r \flowsto \conf{n}$. This requirement enforces the policy that the label of the delegation flows to the clearance of node $n$, meaning that $n$ can observe the presence of a delegation only if the delegation's label flows to $n$'s clearance label.

\paragraph{Strategies}
As delegations are implemented as labeled values, using a delegation in a proof search raises the current label by the label of the delegation, similar to how LIO unlabels labeled values. This makes fine-grained control of how delegations are used important to avoid unnecessary label creep. One approach to such control could be to always unlabel all delegations whose label flows to the clearance label of the node performing the proof search. This would be correct and secure (because all and only delegations whose label flows to the node's clearance label are used in the proof search), but it may raise the current label unnecessarily (i.e., the proof search may examine more delegations than it needs to). In particular, if a delegation is examined, the current label must be raised, even if the delegation is not ultimately used in the proof. Thus if a node has a delegation labeled with a very restrictive label, then all proof searches would be tainted by that label.
An alternative approach would be a proof search algorithm that unlabels just the right delegations to prove the query. However, as delegations are labeled values, the body of the delegation cannot be inspected without unlabeling the value and raising the current label. So an algorithm has to decide whether to unlabel a delegation by inspecting only the label of the delegation and not its body.

For these reasons \lang{} uses \emph{strategies}, which are lists of principals, to specify which delegations are used in a proof search, and in which order. For instance, if the delegation $\lb{r}{p \actsfor q}$ is stored on a node that evaluates the expression \lstinline[mathescape]!withStrategy [s, r, t] (p $\actsfor$ q)! the node first searches for delegations with a label that flows to $s$. Assuming we cannot prove the query $p \actsfor q$ using only these delegations, then delegations with a label that flows to $r$ are used, and the delegation $\lb{r}{p \actsfor q}$ can now be used to complete the proof search. This example demonstrates how programmers can use strategies to control how \lang{} performs fine-grained proof search with specialized strategies for handling delegations. The choice of which strategy to use is application specific, but a reasonable default strategy is $[\mathsf{cur}, \mathsf{clr}]$, where $\mathsf{cur}$ and $\mathsf{clr}$ are the current label and clearance labels of the node respectively. That is, proof search will first try to find a proof for a delegation query without raising the current label at all; if that is not successful, it will then try to use all available delegations.

\paragraph{Forwarding}
In \lang{}, nodes can forward trust checks to other nodes that might have local information (i.e., delegations) about particular trust relationships. Forwarding queries is straightforward as a query $p \actsfor q$ is simply a monadic expression returning a boolean, and such a query can be forwarded to other nodes in \lang{} using remote procedure calls.
A node $n$ can forward trust checking to a node $m$ only if $n$'s current label flows to $\conf{m}$ (i.e., the clearance of $m$). This restriction ensures that $m$ is allowed to learn about the information that caused $n$ to initiate the query; a similar restriction is used to prevent the invocation of other remote procedure calls revealing information inappropriately.  The following snippet demonstrates how a leak can be constructed if we did not perform the check:
\begin{lstlisting}
((*@$\lambda^{\mathsf{Alice}}_{\conf{\mathsf{Alice}}}$@*) _ . do h <- unlabel aliceSecret
               if h then (*@$p \actsfor q$@*) else return 0) ()
\end{lstlisting}
If $\mathsf{aliceSecret}$ is labeled with $\conf{\mathsf{Alice}}$, the unlabel operation will raise the current label $\level_{\mathsf{cur}}$ to $\level_{\mathsf{cur}} \join \conf{\mathsf{Alice}}$ tracking the fact that the computation context contains information at level at most $\level_{\mathsf{cur}} \join \conf{\mathsf{Alice}}$. Upon forwarding the query $p \actsfor q$ to another node $m$, Alice reveals that $\mathsf{aliceSecret}$ contained a non-zero value. Checking that Alice's current label flows to $\conf{m}$ ensures that the forwarding of the query occurs only if  $m$ is allowed to learn this information.

Returning to the secure banking application, consider the implementation of $\mathsf{transfer}$ in Figure~\ref{fig:sec-transfer}, which transfers $n$ dollars from user $u_\mathsf{from}$ to $u_\mathsf{to}$ using access token $\mathsf{tok}$.

\begin{figure}
\centering
\begin{lstlisting}
transfer = (*@$\lambda^{\mathsf{bank}}_{\bot}$@*) tok (*@$\mathsf{u}_\mathsf{from}$@*) (*@$\mathsf{u}_\mathsf{to}$@*) n . do
              u <- unlabel tok
              withStrategy [(*@$\conf{\mathsf{bank}} \conj \integ{\mathsf{u}_{\mathsf{from}}}$@*)]
                (if u (*@$\actsfor$@*) (*@$\mathsf{u}_\mathsf{from}$@*) then transfer# (*@$\mathsf{u}_\mathsf{from}$@*) (*@$\mathsf{u}_\mathsf{to}$@*) n
                 else return ())
\end{lstlisting}
\caption{Secure transfer of $n$ dollars from $u_{\mathsf{from}}$ to $u_{\mathsf{to}}$ using access token $\mathsf{tok}$.}
\label{fig:sec-transfer}
\end{figure}

First, the access token $\mathsf{tok}$ acquired by $\mathsf{login}$ is unlabeled, revealing the identity of the caller. Then, a check is done to ensure that the caller can act on behalf of the user from which money is being transferred. For this example the bank requires the trust relationship to be observable by the bank, and having integrity of the principal from which the money is transferred, which is reflected in the strategy specifying that only delegations at level $\conf{\mathsf{bank}} \conj \integ{\mathsf{u}_{\mathsf{from}}}$ or below (i.e., weaker confidentiality and stronger integrity) are used. Finally, a primitive function $\mathsf{transfer\#}$ performs the actual transfer of money, or if the trust relationship cannot be established, the function returns a unit value. Figure~\ref{fig:bob-transfer-from-alice} demonstrates how Bob can transfer money from Alice if she grants Bob the appropriate trust. First, Alice adds a delegation specifying that Bob can act on behalf of Alice and that this information has the integrity of Alice. Then, Bob performs an RPC to the $\mathtt{login}$ function, which returns an access token. Finally, he transfers 50 dollars from Alice's account to his own account. Note that the use of the strategy $[\conf{\mathsf{bank}} \conj \integ{\mathsf{u}_{\mathsf{from}}}]$ in $\mathtt{transfer}$ ensures not only that the bank uses only delegations it is allowed to observe, but also that the bank does not use a delegation provided by an inappropriate principal such as Bob, as Bob cannot add a delegation labeled with the principal $\integ{\mathsf{Alice}}$ (unless $\mathsf{Alice}$ first delegates trust to $\mathsf{Bob}$).

\begin{figure}
\centering
\begin{lstlisting}
((*@$\lambda^{\mathsf{Alice}}_{\bot}$@*) _ . do assume (*@$\mathsf{Bob}$@*) (*@$\actsfor$@*) (*@$\mathsf{Alice}$@*) @ (*@$\integ{\mathsf{Alice}}$@*)
              ((*@$\lambda^{\mathsf{Bob}}_{\bot}$@*) _ . do tok <- login (*@$\mathsf{Bob}$@*) "password"
                            transfer tok (*@$\mathsf{Alice}$@*) (*@$\mathsf{Bob}$@*) 50) ()) ()
\end{lstlisting}
\caption{Alice grants Bob access to perform transfers on her behalf.}
\label{fig:bob-transfer-from-alice}
\end{figure}