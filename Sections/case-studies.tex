We have implemented \lang{} as a library in Haskell \cite{flamiolib}. The code is approximately 2200 lines of code and uses the efficient query resolution algorithm for authorization queries described in \cite{Arden:2015:FA:2859845.2859998}, along with additional layers of caching to avoid repeated network communication. To simplify the implementation, we differ from the calculus in the following ways:
\begin{enumerate}
    \item \label{enum:no-func-across-network} An RPC invocation does not send the function that should be called across the network. Instead, the receiver of the RPC has a table mapping identifiers to functions, and the caller sends this identifier along with the list of arguments.
    \item \label{enum:cache-network-queries} Since query results obtained via network communication is cached on a per-query basis, no two identical queries are sent to the same node.
    \item \label{enum:del-1-rule} The \ruleref{Del-1} rule does not inspect the principals in the delegation before it unlabels them but instead unlabels all delegations whose label flow to the strategy.
\end{enumerate}

First, \ref{enum:no-func-across-network}) does not lead to loss of expressivity: As shown in \cite{Cooper:2009:RC:1599410.1599439} one can translate a program written in a calculus similar to the calculus presented in Section~\ref{sec:calculus} to a program written in Haskell using the \lang{} implementation by performing defunctionalization.

Second, \ref{enum:cache-network-queries}) reduces network communication a lot, but means that the implementation is unsound if the trust relationship between principals changes during query resolution. In practice, this is not an issue, as orthogonal work on query isolation \cite{Liu:2009:FPS:1629575.1629606} can provide transactional behavior for distributed systems like \lang.

Third, \ref{enum:del-1-rule}) simplifies the implementation by not breaking the model of LIO: Labeled values remain completely ``opaque'' until unlabeled, which is not the case for the semantics described in Section~\ref{sec:calculus}. By adhering to the model of LIO, the guarantees given in previous work on LIO \cite{SRMMlio} remain true. Furthermore, unlabeling more delegations makes the usage of strategies even more important, as this provides customization of query resolution specifically to a given application domain.

Using this implementation, we have constructed three use cases for \lang. The first use case is a distributed bank, which was already presented in Section~\ref{sec:programming}. The banking example shows how users can perform remote procedure calls to handle transactions across accounts between different users. A user $u$ can authorize another user $u'$ to transfer money on behalf $u$ by adding a delegation specifying that $u'$ can act on behalf of $u$ and rely on forwarding trust queries to resolve the authorization policy.

In addition to the banking example, we have constructed a secure social jukebox service where people can schedule music during social gatherings. Finally, the third use case is a secure database containing confidential information about government agencies. For a type $\type$ we write $L\type$ to denote the type $\labeled{\type}$. That is, \lstinline|LUnit| abbreviates \lstinline|Labeled Unit|.

\subsection{A secure social jukebox service}\label{subsec:jukebox}
We now consider a secure version of a social jukebox service. A group of principals $\Nameset$ is gathered at a party and want to vote on which songs should be played at the party. Furthermore, the principals do not want their votes leaked to the other principals. We assume a distinguished principal $J \in \Nameset$ (for jukebox) representing a node on which two functions exist:
\begin{align*}
\mathtt{get}&: \liotype{(\pair{\String}{\listtype{\pair{\String}{\listtype{\llabeltype}}}})}\\
\mathtt{put}&: (\pair{\String}{\listtype{\pair{\String}{\listtype{\llabeltype}}}}) \to \liotype{\unit}
\end{align*}
Function $\mathtt{get}$ retrieves a pair containing the current song being played, and a list of pairs containing a song and labeled principals representing who votes for this song. By labeling the votes with the label $\conf{J}$ they can securely be distributed for anyone to inspect, as no principal except for $J$ can unlabel the votes. However, while each vote is a labeled value, the list itself is not labeled so everyone can see which song has the most votes. Because of this, any node is free to call $\mathtt{get}$ without inappropriately learning confidential voter information.

Figure~\ref{fig:vote-for-song} implements a function $\mathtt{vote}$ that receives a song title, labeled with the identity of the voter, and updates the vote count using a function $\mathtt{insert}$. Figure~\ref{fig:jukebox-alice-votes-for-taylor-swift} shows an example of $\mathsf{Alice}$ voting for ``Shake it Off'' by Taylor Swift. First, Alice adds a delegation that allows $J$ to read Alice's labeled vote. She then labels her vote and invokes the $\mathtt{vote}$ function. When $\mathtt{vote}$ then unlabels the labeled song title, a forward query to Alice will be issued checking $\integ{J} \join \mathsf{Alice} \flowsto \conf{J}$, which is equivalent to $\conf{J} \conj \integ{(J \disj \mathsf{Alice})} \actsfor \conf{\mathsf{Alice}}$, and holds by the delegation that Alice placed in Figure~\ref{fig:jukebox-alice-votes-for-taylor-swift}.

\begin{figure}
\centering
\begin{lstlisting}
vote = (*@$\lambda^{J}_{\botinfoflow}$@*) ls . do
  let p = labelOf ls
  s <- unlabel ls
  (curSong, songs) <- get
  lp <- label (*@$\conf{J}$@*) p
  put (curSong, insert lp s songs)
\end{lstlisting}
\caption{Implementing secure voting functionality}
\label{fig:vote-for-song}
\end{figure}

\begin{figure}
\centering
\begin{lstlisting}
((*@$\lambda^{\mathsf{Alice}}_{\botinfoflow}$@*) _ . do assume (*@$\conf{J}$@*) (*@$\actsfor$@*) (*@$\conf{\mathsf{Alice}}$@*) @ (*@($\conf{\bot} \conj \integ{$ J$}$)@*)
  ls <- label (*@$\mathsf{Alice}$@*) "Taylor Swift - Shake It Off"
  vote ls) ()
\end{lstlisting}
\caption{$\mathsf{Alice}$ places a secret vote for Taylor Swift.}
\label{fig:jukebox-alice-votes-for-taylor-swift}
\end{figure}

\subsection{Government agency records}\label{subsec:agents}
As a final example demonstrating the usefulness of \lang, we show how confidential delegations can be used to keep government agency records. For this example, we use a simple extension of \lang{} that allows ownership projections as nodes in the system. The example could be rewritten to delegate the ownership projections to named principals, but we omit this to simplify the presentation of the example.

Figure~\ref{fig:govt-alice-checks-bob} shows an example of a scenario where $\owner{\mathsf{CIA}}{\mathsf{Alice}}$ verifies that $\mathsf{Bob}$ is also a secret agent. First, $\mathsf{Alice}$ and $\mathsf{Bob}$ are both hired as secret agents by the $\mathsf{CIA}$ by delegating the principal $\mathsf{Agents}$ to $\owner{\mathsf{CIA}}{\mathsf{Alice}}$ and $\owner{\mathsf{CIA}}{\mathsf{Bob}}$. Not everyone should know that they are secret agents, and so we put the confidentiality of this delegation to be $\mathsf{Agents}$, such that only agents can learn the identity of other agents.

At some point $\mathsf{Alice}$ meets $\mathsf{Bob}$ ``in the field'' and wants to verify his claim that he is a secret agent for the $\mathsf{CIA}$. In order for $\mathsf{Alice}$ to verify this she has to check if the principal $\mathsf{Agents}$ delegates to $\owner{\mathsf{CIA}}{\mathsf{Bob}}$. For $\mathsf{Alice}$ to prove this query she uses the \ruleref{Fwd} rule and delegates the query to the $\mathsf{CIA}$ principal. The $\mathsf{CIA}$ principal proves the query $\owner{\mathsf{CIA}}{\mathsf{Bob}} \actsfor \mathsf{Agents}$ using delegations up to level $\mathsf{Agents}$ in the process. So for $\mathsf{Alice}$ to use this information she must prove that $\mathsf{Agents} \flowsto \owner{\mathsf{CIA}}{\mathsf{Alice}}$. This can be done using another application of the \ruleref{Fwd} rule which contacts the $\mathsf{CIA}$ principal and proves the query. Note that, once again, $\mathsf{Alice}$ has to prove that $\mathsf{Agents} \flowsto \owner{\mathsf{CIA}}{\mathsf{Alice}}$ in order to use the delegation provided by the $\mathsf{CIA}$. But now $\mathsf{Agents} \flowsto \owner{\mathsf{CIA}}{\mathsf{Alice}}$ becomes an assumption, and $\mathsf{Alice}$ can prove the required trust relationship using \ruleref{Hyp}.
$\mathsf{Alice}$ can now trust the answer received from $\mathsf{CIA}$ and know if $\mathsf{Bob}$ is also a secret agent.

\begin{figure}
\centering
\begin{lstlisting}
((*@$\lambda^{\owner{\mathsf{CIA}\,}{\,\mathsf{Alice}}}$@*) _ . assume (*@$\integ{\mathsf{Agents}}$@*) (*@$\actsfor$@*) (*@$\integ{\owner{\mathsf{CIA}}{\mathsf{Alice}}}$@*) @ (*@$\owner{\mathsf{CIA}}{\mathsf{Alice}}$@*)) ()
[...]
((*@$\lambda^{\mathsf{CIA}}$@*) _ . assume (*@$\owner{\mathsf{CIA}}{\mathsf{Alice}}$@*) (*@$\actsfor$@*) (*@$\mathsf{Agents}$@*) @ (*@$\mathsf{Agents}$@*)
           assume (*@$\owner{\mathsf{CIA}}{\mathsf{Bob}}$@*) (*@$\actsfor$@*) (*@$\mathsf{Agents}$@*) @ (*@$\mathsf{Agents}$@*)) ()
[...]
((*@$\lambda^{\mathsf{Alice}}$@*) _ . isAgent <- (*@$\owner{\mathsf{CIA}}{\mathsf{Bob}}$@*) (*@$\actsfor$@*) agents
         if isAgent then
           // Alice can trust Bob to be a secret agent
         else [...]) ()
\end{lstlisting}
\caption{$\mathsf{Alice}$ verifies that $\mathsf{Bob}$ is a secret agent for the $\mathsf{CIA}$.}
\label{fig:govt-alice-checks-bob}
\end{figure}