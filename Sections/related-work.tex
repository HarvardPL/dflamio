\paragraph{FLAM}
The FLAM technical report \cite{flamtr} presents a security-typed language $\mathsf{F}\lambda$ in which policies are FLAM principals. Much like \lang{}, $\mathsf{F}\lambda$ can delegate trust during evaluation and allows querying of trust relationships. However, the decision of whether or not to allow downgrading (i.e., adding new trust relationships) must be performed statically using a relatively simple type system. In \lang{} all decisions about whether to allow downgrading is done during evaluation, meaning that \lang{} can potentially allow more downgrading and remain secure. As $\mathsf{F}\lambda$ is a language with fine-grained IFC the programmer is also burdened with many more labels than what one might expect to see in similar \lang{} programs.

FLAC \cite{7536372} is a calculus for flow-limited authorization, which allows static reasoning about mechanisms such as commitment schemes or bearer credentials that require dynamic authorization. FLAC builds a sophisticated type system on top of FLAM and proves noninterference and robust declassification properties for the language. While FLAC offers many high-level features necessary to build practical authorization mechanisms, it uses a limited subset of FLAM (i.e., it does not have a rule equivalent to FLAM's \ruleref{Fwd} rule for distributed trust checking). Furthermore, FLAC does not consider evaluation with side effects (other than adding trust relationship) and does not include convenient imperative features found in many languages like mutable references.

Hyperflow \cite{hyperflow} is a new processor architecture for nonmalleable, timing-sensitive IFC that uses FLAM principals encoded as bit vectors as the label model. This encoding offers efficient computation of joins, meets, and projections. Using this encoding Hyperflow extends the RISC-V processor with IFC instructions and limits how information flows through registers and memory pages. The hardware is programmed in a new hardware-description language, ChiselFlow, embedded in Scala. Much like \lang{}, each process in a Hyperflow processor contains a current label and a clearance label, but unlike our model, Hyperflow requires that the programmer to explicitly raise the current label. This decision avoids the possible side-channel caused by raising the current label depending on sensitive information (a channel that we close in \lang), at the cost of putting the burden of raising the label on the programmer.

\paragraph{LIO and coarse-grained information-flow}
The original formulation of LIO \cite{SRMMlio} has been extended in many dimensions. Concurrent LIO \cite{Stefan:2012:ACT:2364527.2364557} extends LIO with concurrency primitives such as forking and synchronization. As computation is concurrent in this language, the termination-channel is amplifiable \cite{Askarov:2008:TNL:1462455.1462485} and must be closed. In \cite{Stefan:2012:ACT:2364527.2364557} the authors shows that LIO can be shown to satisfy termination-sensitive noninterference by removing the $\tolabeledkw$ primitive from the language. This removal is detrimental to the usability of LIO, and thus \cite{Stefan:2012:ACT:2364527.2364557} introduces a version of $\tolabeledkw$ that is safe in a concurrent setting. Intuitively, the dangerous part of $\tolabeledkw$ is that one can perform synchronization across threads inside a $\tolabeledkw$ expressions, and then leak via an internal timing attack. The solution to this problem is that a concurrent version of $\tolabeledkw$ should spawn a new thread, and not raise the current label until synchronization is performed. In \lang{} it is secure to have a simple $\tolabeledkw$ construct as internal timing attacks are not possible. Using $\tolabeledkw$ label creep can be mitigated by the same techniques that programmers already know from \cite{SRMMlio}.

Recent work \cite{Rajani2018, Vassena2019} on the expressiveness of fine-grained versus coarse-grained information flow shows that they have the same expressive power, and the authors of \cite{Rajani2018} suggest preferring coarse-grained information flow tracking as opposed to fine-grained information-flow tracking, as the former put less burden on the programmer. Based on our experience with \lang{}, we agree with this observation.

\paragraph{Remote procedure call and distributed computation}
Our model for remote procedure calls is inspired by the \emph{Location-aware Simple Abstract Machine} (LSAM) \cite{10.1007/978-3-642-25462-8_28}. In our terminology, a global LSAM configuration is a set of local LSAM configurations indexed by names. A remote procedure call is performed by suspending the computation and transferring control to another local LSAM configuration. While \cite{10.1007/978-3-642-25462-8_28} considers a first-order language useful as a target language for compiling other languages for distributed computation, our semantics handles higher-order functions in the style of the source language in \cite{Cooper:2009:RC:1599410.1599439}, and LSAM would be a natural compilation target for our work.

Much work has been devoted to information-flow programming languages for distributed systems. Both SIF \cite{Chong:2007:SEC:1362903.1362904} and Swift \cite{Chong:2007:SWA:1294261.1294265} are based on Jif \cite{Myers:1999:JPM:292540.292561}, and targets web applications by tracking confidentiality and integrity of data sent between a server and a client. Fabric \cite{Liu:2009:FPS:1629575.1629606} extends Jif with remote procedure calls and transactions, and enforces security by using a combination of static and dynamic enforcement mechanisms. Fabric and \lang{} share many features: Both have trust orderings on principals that can be queried and modified at runtime, and remote nodes communicate via RPC. On the other hand, Fabric and \lang{} differ in many ways: Fabric is a language with fine-grained IFC, while \lang{} is a coarse-grained system build as a library directly on top of LIO, which in itself is a library in Haskell. The label model of Fabric, SIF, and Swift is based on DLM \cite{Myers:2000:PPU:363516.363526} and are thus all vulnerable to delegation loophole attacks and do not attempt to control read channels \cite{Zdancewic:2002:SPP:566340.566343}. As \lang{} uses the FLAM label model, these attacks are not possible in \lang{}.