\paragraph{FLAM}
The FLAM technical report \cite{flamtr} presents a security-typed language $\mathsf{F}\lambda$ in which policies are FLAM principals. Much like \lang{}, $\mathsf{F}\lambda$ can delegate trust during evaluation and allows querying of trust relationships. However, the decision of whether or not to allow downgrading (i.e., adding new trust relationships) must be performed statically using a relatively simple type system. In \lang{} all decisions about whether to allow downgrading are done during evaluation, meaning that \lang{} can potentially allow more downgrading and remain secure. As $\mathsf{F}\lambda$ is a language with fine-grained IFC the programmer is also burdened with many more labels than what one might expect to see in similar \lang{} programs.

FLAC \cite{7536372} is a calculus for flow-limited authorization, which allows static reasoning about mechanisms such as commitment schemes or bearer credentials that require dynamic authorization. FLAC builds a sophisticated type system on top of FLAM and proves noninterference and robust declassification properties for the language. While FLAC offers many high-level features necessary to build practical authorization mechanisms, it uses a limited subset of FLAM (i.e., it does not have a rule equivalent to FLAM's \ruleref{Fwd} rule for distributed trust checking). Furthermore, FLAC does not consider evaluation with side effects (other than adding trust relationship) and does not include convenient imperative features found in many languages like mutable references.

Hyperflow \cite{hyperflow} is a new processor architecture for nonmalleable, timing-sensitive IFC that uses FLAM principals encoded as bit vectors as the label model. This encoding offers efficient computation of joins, meets, and projections. Using this encoding, Hyperflow extends the RISC-V processor with IFC instructions and limits how information flows through registers and memory pages. The hardware is programmed in a new hardware-description language, ChiselFlow, embedded in Scala. Much like \lang{}, each process in a Hyperflow processor contains a current label and a clearance label, but unlike our model, Hyperflow requires that the programmer explicitly raises the current label. This decision avoids the possible side-channel caused by raising the current label depending on sensitive information (a channel that we close in \lang), at the cost of putting the burden of raising the label on the programmer.

\paragraph{LIO and coarse-grained information-flow}
Coarse-grained IFC has traditionally been applied mostly in operating system security \cite{Zeldovich:2006:MIF:1267308.1267327, Krohn:2007:IFC:1294261.1294293} by associating a single label with a process. LIO \cite{SRMMlio} implements coarse-grained IFC as a monadic Haskell library using a notion of a current label that can float up to the computation's clearance label, similar to \lang.

Recent work \cite{Rajani2018, Vassena2019} on the expressiveness of fine-grained versus coarse-grained information flow shows that they have the same expressive power, and the authors of \cite{Rajani2018} suggest using coarse-grained, as it puts less burden on the programmer. Based on our experience with \lang{}, we agree with this observation.

\paragraph{Remote procedure calls and distributed computation}
Our semantics for remote procedure calls is inspired by the \emph{Location-aware Simple Abstract Machine} (LSAM) \cite{10.1007/978-3-642-25462-8_28}. A global LSAM configuration is a set of local LSAM configurations indexed by names, and remote procedure calls are performed by suspending the computation and transferring control to another local LSAM configuration. While the authors of \cite{10.1007/978-3-642-25462-8_28} consider a first-order language, useful as a target language for compiling other languages for distributed computation, our semantics handles higher-order functions in the style of the source language in \cite{Cooper:2009:RC:1599410.1599439}, and LSAM would be a natural compilation target for our work.

Much work has been devoted to information-flow programming languages for distributed systems. Both SIF \cite{Chong:2007:SEC:1362903.1362904} and Swift \cite{Chong:2007:SWA:1294261.1294265} are based on Jif \cite{Myers:1999:JPM:292540.292561}, and target web applications by tracking confidentiality and integrity of data sent between a server and a client. Fabric \cite{Liu:2009:FPS:1629575.1629606} extends Jif with remote procedure calls and transactions, and enforces security by using a combination of static and dynamic enforcement mechanisms. Fabric and \lang{} share many features: Both have trust orderings on principals that can be queried and modified at runtime, and remote nodes communicate via RPC. On the other hand, Fabric and \lang{} differ in many ways: Fabric is a language with fine-grained IFC, while \lang{} is a coarse-grained system build as a library directly on top of LIO, which in itself is a library in Haskell.

Fabric prevents information leakage from \emph{read channels} (i.e., if node $n$ accesses data on node $m$ depending on information confidential to $n$, node $m$ learns about $n$'s confidential information) using \emph{access labels}, but does not protect against read channels arising from authorization queries \cite{Arden:2015:FA:2859845.2859998}.