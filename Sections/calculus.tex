This section introduces a formalization of the \lang{} language. We first introduce the syntax and semantics of the language, and afterwards present the judgment for deriving trust between principals in the language. Finally, this section presents a type system for \lang.

\subsection{Syntax}

Figure~\ref{fig:language-syntax} shows the syntax of \lang. The meta-variable $\val$ ranges over terms, which include boolean literals, the unit value, runtime representations of principals, addresses and variables, abstractions $\abs{n}{\lb{p}{\type}}{x}{\expr}$, which are parameterized over the principal name $n$ on which to evaluate the expression $\expr$, and the label on the value returned from invoking the abstraction.

Expressions are ranged over by the meta-variable $\expr$ and include terms, applications, projections, elimination of booleans and lists, recursive functions, monadic expressions using $\returnkw$ and $\bindop$ (pronounced ``bind''), allocation, reading and writing of references. Following LIO \cite{SRMMlio} the language supports operations for labeling and unlabeling expressions, and the operation $\tolabeledkw$ for controlling label-creep \cite{where do they introduce label-creep?}. The operations $\getlabel$ and $\getclearance$ returns the current label and clearance respectively, and $\labelofkw$ returns the label of a labeled expression. Following \cite{Extensible Access Control with Authorization Contracts} the scope of delegations is ``fluid'' and the operation $\withscopekw$ creates a new fluid scope. Strategies (introduced later in this section) is introduced using the $\withstrategykw$ operation, and can be obtained using $\getstrategy$. Finally, delegations an be added and queried. The shaded regions describe syntax not part of the surface language, but rather constructs used during evaluation.

Finally, types are ranged over by the meta-variable $\type$ and include standard types like the boolean type, the unit type, function, list and product types. Non-standard types include the type of FLAM principals, the type of labeled values, the type of LIO computations and location-aware reference types.

\begin{figure*}
    \centering
    \begin{tabular}{l}
         $\val ::= \true \mid \false \mid () \mid p \mid \addr \mid x \mid \abs{n}{\lb{p}{\type}}{x}{\expr} \mid (\expr, \expr) \mid \cons{\expr}{\expr} \mid \nil \mid \graybox{\lb{p}{\expr}} \mid \graybox{\lio{\expr}}$ \\
         $\begin{aligned}[t]
         \expr ::=&\;\; \val \mid \app{\expr}{\expr} \mid \proj{i}{\expr} \mid \ifexpr{\expr}{\expr}{\expr} \mid \case{\expr}{\expr}{\expr} \mid \fix{\expr} \mid \return{\expr} \mid \bind{\expr}{\expr} \\ &\mid
         \new{\expr}{\expr} \mid \readref{\expr} \mid \writeref{\expr}{\expr} \mid \Label{\expr}{\expr} \mid \unlabel{\expr} \mid
         \tolabeled{\expr}{\expr} \mid \getlabel \\ &\mid \getclearance \mid \labelof{\expr} \mid \withscope{\expr} \mid \expr \actsfor \expr \mid \withstrategy{\expr}{\expr} \\ &\mid \adddelegate{\expr}{\expr}{\expr} \mid \getstrategy \mid \graybox{\wait{n}[\type]} \mid \graybox{\resetstrategy{\overline{p}}{\expr}} \\ &\mid \graybox{\resetTolabeled{p}{q}{\expr}} \mid \graybox{\resetscope{\scope}{\expr}}
         \end{aligned}$ \\
         %$\overline{\expr} ::= \expr; \overline{\expr} \mid \termsym$ \\
         $\type ::= \bool \mid \unit \mid \func{\type}{\type} \mid \listtype{\type} \mid \pair{\type}{\type} \mid \labeltype \mid \labeled{\type} \mid \liotype{\type} \mid \reftype[n]{\type}$ \\
    \end{tabular}
    \caption{The \lang{} language}
    \label{fig:language-syntax}
\end{figure*}

\subsection{Semantics}
The semantics of \lang{} can be split into two judgments: Local reduction rules, which evaluates an expression on a specific node $n$; and global reduction rules, which models remote procedure calls and returns. We first present the local reduction rules.

\paragraph{Local semantics}
The semantics of local reduction rules is given by a structured operational semantics with evaluation contexts \cite{cite-felleisen-duh}. We elide the definition of the evaluation context, as this is mostly standard.

We further split the local reduction rules into two categories: Pure reduction rules $\steppure{\expr}{\expr'}$ which reduces independent of memories and independent of which principal is evaluating the expression. The pure reduction rules are seen in Figure~\ref{fig:pure-reductions}. Pure reductions include packing terms into monadic contexts, monadically binding terms, recursive applications, projecting pairs, eliminating booleans and lists and obtaining the label of a labeled value.

\begin{figure}
    \centering
    \begin{mathpar}
    \inferrule{}{\steppure{\efill{\return{\val}}} {\efill{\lio{\val}}}}
    \and
    \inferrule{}{\steppure{\efill{\bind{\lio{\val}}{\expr}}}{\efill{\app{\expr}{\val}}}}
    \and
    \inferrule{}{\steppure{\efill{\fix{\expr}}}{\efill{\app{\expr}{(\fix{\expr})}}}}
    \and
    \inferrule{}{\steppure{\efill{\proj{i}{(\val_1, \val_2)}}}{\efill{\val_i}}}
    \and
    \inferrule{}{\steppure{\efill{\ifexpr{b}{\expr_{\true}}{\expr_{\false}}}}{\efill{\expr_b}}}
    \and
    \inferrule{}{\steppure{\efill{\case{\nil}{\expr_1}{\expr_2}}}{\efill{\expr_1}}}
    \and
    \inferrule{}{\steppure{\efill{\case{(\cons{\expr_\hd}{\expr_\tl})}{\expr_1}{\expr_2}}}{ \efill{\app{\app{\expr_2}{\expr_\hd}}{\expr_\tl}}}}
    \and
    \inferrule{}{\steppure{\efill{\labelof{(\lb{p}{\expr})}}}{\efill{p}}}
    \and
    \inferrule{\steppure{\expr}{ \expr'}}{\steppure{\efill{\expr}}{\efill{\expr'}}}
    \end{mathpar}
    \caption{Pure reductions for \lang.}
    \label{fig:pure-reductions}
\end{figure}

The remaining local reductions all depend either on memory or on the identity of the principal which evaluates the expression. We denote these as ``monadic reductions''.

Before introducing the monadic small-step local reduction, we introduce the remaining necessary concepts: First, a store $\store: \Addr \to \val$ is a mapping from addresses to values. A local configuration is a pair $\config{\store}{\expr}$ consisting of a store $\store$ and an expression $\expr$. \TODO{These are actually expression stacks. Find a better way to introduce this.} A global environment $\env: \Nameset \to \sigma$ is a mapping from names to local environments $\sigma$. A local environment contains the current label $\lblkw$, the set of delegations local to the principal $\scope$ and the current strategy of the principal. We use record notation for these and write $\sigma.\lblkw$, $\sigma.\scope$ and $\sigma.\strategy$ respectively.

The small-step relation is written $\step{n; \env}{\config{\store}{\expr}}{\config{\store'}{\expr'}}{\sigma}$ and should be read as ``on machine $n$ with global environment $\env$ the configuration performs a single reduction and updates its local environment from $\env_n$ to $\sigma$''.

Figure~\ref{fig:monadic-reductions} in the appendix shows the local reduction rules. Most of the rules verify some trust relationship between principals, written $\actsforquery{n; \env}{p}{q}{\level}$ and can be read as ``node $n$ proves that $p$ acts for $q$ and uses information labeled up to $\level$ in the process''. We will discuss this judgment later in this section.

Rule \ruleref{E-Lift-Pure} lifts pure reductions to monadic reductions. Rules \ruleref{E-Get-Label} and \ruleref{E-Get-Clearance} returns current label or clearance of the principal upon which the expression is being evaluated. Rule \ruleref{E-App} applies a function to an argument and labels the resulting value with the given principal. Rules \ruleref{E-New}, \ruleref{E-Read}, \ruleref{E-Write}, \ruleref{E-Label} and \ruleref{E-Unlabel} are all equivalent to the ones presented in \cite{SRMMlio}, but now also takes into account the possible information-flows arising via deriving trust relationships. Rules \ruleref{E-ToLabeled-1} and \ruleref{E-ToLabeled-2} evaluates an expression $\expr$, but once $\expr$ is evaluated to a term $\val$, the current label is restored to its state before evaluation of $\expr$ began. This operation helps prevent label creep, and security guarantees can be reestablished by labeling $\val$. Note that the presentation of this operation is different from \cite{SRMMlio} in that we avoid interleaving small-step and big-step operations, which simplifies the proofs considerably.

Rules \ruleref{E-Acts-For-True} and \ruleref{E-Acts-For-False} queries the trust relationship between two given principals. Rules \ruleref{E-With-Scope} and \ruleref{E-Reset-Scope} introduces and eliminate a fluid scope respectively. Rules \ruleref{E-With-Strategy} introduces a new strategy and executes an expression in the lexical scope of the new strategy. Rule \ruleref{E-Reset-Strategy} eliminates the strategy once the expression reduces to a term. Finally, \ruleref{E-Assume} adds a new delegation. This rule uses the voice operator $\voicekw$ which was defined in Section~\ref{sec:background}.

\paragraph{Global semantics}

\subsection{Deriving trust relationship in \lang}

Talk about:
\begin{enumerate}
    \item The grammar
    \item The evaluation context
    \item The local reduction rules
    \item Discuss the usage of strategies
    \item The global reduction rules
    \item The type system
    \item Show preservation
    \item Talk about the invariant used for preservation?
\end{enumerate}