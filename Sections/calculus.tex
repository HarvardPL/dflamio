This section introduces a formalization of the \lang{} language. We first introduce the syntax and semantics of the language and afterward present the judgment for deriving trust between principals in the language. Finally, this section presents a type system for \lang. 

\subsection{Syntax}
Figure~\ref{fig:language-syntax} shows the syntax of \lang. The meta-variable $\val$ ranges over terms, which include boolean literals, the unit value, runtime representations of principals, locations and variables, abstractions $\abs{n}{\lb{p}{\type}}{x}{\expr}$, which are parameterized over the node $n$ on which to evaluate the expression $\expr$, and the principal $p$ representing the label on the value returned from invoking the abstraction. To simplify the presentation of the semantics abstractions are annotated with the type of $\expr$, but we will continue to omit such type annotations in examples. Finally, the language includes lists using $\nil$ and $\consop$ (pronounced \emph{cons}) to model strategies.

Expressions are ranged over by the meta-variable $\expr$ and include terms, applications, projections, elimination of booleans and lists, recursive functions, monadic expressions using $\returnkw$ and $\bindop$, allocation, reading and writing of references. Following LIO, the language supports operations for labeling and unlabeling expressions, and the operation $\tolabeledkw$ for controlling label-creep. The operations $\getlabel$ and $\getclearance$ returns the current label and clearance of the computational context respectively, and $\labelofkw$ returns the label of a labeled value. The scope of delegations is \emph{fluid} \cite{Moore:2016:EAC:2983990.2984021} and the operation $\withscopekw$ creates a new fluid scope. Traditionally, the scope of a variable binding describes the spatial and temporal part of the program in which the variable is visible. Following \cite{Moore:2016:EAC:2983990.2984021} we call the spatial aspect of scoping the \emph{scope}, and the temporal aspect of scoping the \emph{extent}. Dynamic scoping often refers to scoping that has dynamic extent and ``indefinite'' scope, while fluid scoping is scoping that has dynamic extend and lexical scoping.

Strategies are introduced using the $\withstrategykw$ operation, and the current strategy can be obtained using $\getstrategy$. Finally, delegations can be added and trust relationships can be queried. The shaded regions describe syntax that is not part of the surface language, but rather constructs used during evaluation: expression $\wait{n}[\type]$ waits for node $n$ to respond from an RPC call returning a value of type $\type$, and $\internalTolabeled{p}{q}{\expr}$ performs a toLabeled-computation and resets the current label to $p$ afterwards. The remaining constructs are used to reset parts of the state after computations inside $\withstrategykw$ and $\withscopekw$ evaluates to values. \TODO{I don't like actually explaining the syntax not part of the surface language in this section, but reviewer $C$ really wants this right away. What do you think?}

Finally, types are ranged over by the meta-variable $\type$ and include standard types like the boolean type; the unit type; as well as function-, list- and product types. Non-standard types include the type of FLAM principals, the type of labeled values, the type of LIO computations as well as location-aware reference types. The location refers to the node on which the reference has been allocated.

\begin{figure}
    \centering
    \begin{tabular}{l}
         $\begin{aligned}[t]
         \val &::= \true \mid \false \mid () \mid p \mid \addr \mid x \mid \abs{n}{\lb{p}{\type}}{x}{\expr} \mid (\expr, \expr) \mid \cons{\expr}{\expr} \\
         &\quad \mid \nil \mid \graybox{\lb{p}{\expr} \mid \lio{\expr}}
         \end{aligned}$ \\
         $\begin{aligned}[t]
         \expr &::= \val \mid \app{\expr}{\expr} \mid \proj{i}{\expr} \mid \ifexpr{\expr}{\expr}{\expr} \mid \case{\expr}{\expr}{\expr} \mid \fix{\expr} \\ &\quad \mid \return{\expr} \mid \bind{\expr}{\expr} \mid
         \new{\expr}{\expr} \mid \readref{\expr} \mid \writeref{\expr}{\expr} \mid \Label{\expr}{\expr} \\ &\quad
         \mid \unlabel{\expr} \mid
         \tolabeled{\expr}{\expr} \mid \getlabel \mid \getclearance \\ &\quad
         \mid \labelof{\expr} \mid \withscope{\expr} \mid \expr \actsfor \expr \mid \withstrategy{\expr}{\expr} \\ &\quad \mid \adddelegate{\expr}{\expr}{\expr} \mid \getstrategy
         \mid \graybox{\wait{n}[\type]} \\ &\quad
         \mid \graybox{\internalTolabeled{p}{q}{\expr} \mid \resetstrategy{\overline{p}}{\expr} \mid \resetscope{\scope}{\expr}}
         \end{aligned}$ \\
         $\begin{aligned}[t]
         \type &::= \bool \mid \unit \mid \func{\type}{\type} \mid \listtype{\type} \mid \pair{\type}{\type} \mid \labeltype \mid \labeled{\type} \\ &\quad
         \mid \liotype{\type} \mid \reftype[n]{\type}
         \end{aligned}$
    \end{tabular}
    \caption{The \lang{} language}
    \label{fig:language-syntax}
\end{figure}

\subsection{Semantics}\label{sec:semantics}
The semantics of \lang{} can be split into two judgments: Local reduction rules, which evaluate an expression on a specific node; and global reduction rules, which models remote procedure calls (RPC) and returns. We first present the local reduction rules.

\paragraph{Local semantics}
The semantics of local reduction rules is given by a structured operational semantics with evaluation contexts \cite{Felleisen:1988:TPF:73560.73576}. We elide the definition of the evaluation context, as this is mostly standard.

We further split the local reduction rules into two categories: Pure reduction rules $\steppure{\expr}{\expr'}$ which reduces expressions independently of the store and of which node is evaluating the expression. The pure reduction rules are given in Figure~\ref{fig:pure-reductions}. Pure reductions include injecting terms into monadic contexts, monadically binding terms, recursive applications, projecting pairs, eliminating booleans and lists and obtaining the label of a labeled value.

\begin{figure}
    \centering
    \begin{mathpar}
    \inferrule{}{\steppure{\efill{\return{\val}}} {\efill{\lio{\val}}}}
    \and
    \inferrule{}{\steppure{\efill{\bind{\lio{\val}}{\expr}}}{\efill{\app{\expr}{\val}}}}
    \and
    \inferrule{}{\steppure{\efill{\fix{\expr}}}{\efill{\app{\expr}{(\fix{\expr})}}}}
    \and
    \inferrule{}{\steppure{\efill{\proj{i}{(\val_1, \val_2)}}}{\efill{\val_i}}}
    \and
    \inferrule{}{\steppure{\efill{\ifexpr{b}{\expr_{\true}}{\expr_{\false}}}}{\efill{\expr_b}}}
    \and
    \inferrule{}{\steppure{\efill{\case{\nil}{\expr_1}{\expr_2}}}{\efill{\expr_1}}}
    \and
    \inferrule{}{\steppure{\efill{\case{(\cons{\expr_\hd}{\expr_\tl})}{\expr_1}{\expr_2}}}{ \efill{\app{\app{\expr_2}{\expr_\hd}}{\expr_\tl}}}}
    \and
    \inferrule{}{\steppure{\efill{\labelof{(\lb{p}{\expr})}}}{\efill{p}}}
    \and
    \inferrule{\steppure{\expr}{ \expr'}}{\steppure{\efill{\expr}}{\efill{\expr'}}}
    \end{mathpar}
    \caption{Pure reductions for \lang.}
    \label{fig:pure-reductions}
\end{figure}

The remaining local reductions all depend either on store or on the identity of the node that evaluates the expression. We denote these as \emph{monadic reductions}.

Before introducing the monadic small-step local reduction, we introduce the remaining necessary concepts: First, a store $\store: \Addr \partialto \val$ is a partial mapping from locations to terms, and we write the empty store as $\varnothing$. A local configuration is a pair $\config{\store}{\overline{\expr}}$ consisting of a store $\store$ and a stack of expressions $\overline{\expr}$. We use stacks of expressions to handle incoming remote procedure calls which ``interrupts'' the current computation to evaluate the RPC. A global environment $\env: \Nameset \to \sigma$ is a mapping from names to local environments $\sigma$. A local environment $(\lblkw, \scope, \strategy)$ contains the current label ($\lblkw$), the set of delegations local to the node ($\scope$) and the current strategy of the node. ($\strategy$). We use record notation for these and write $\sigma.\lblkw$, $\sigma.\scope$ and $\sigma.\strategy$ respectively. We let $\emptyenv$ denote the initial global environment satisfying $\emptyenv(n) = (\conf{\bot} \conj \integ{n}, \emptyset, \nil)$. That is, the initial global environment maps all names to an initial local environment with a current label $\conf{\bot} \conj \integ{n}$, the empty set of delegations $\emptyset$ and the empty strategy. While this notation conflicts with the empty store, the context always allows for disambiguation.

The monadic small-step relation is written $\step{n; \env}{\config{\store}{\expr}}{\config{\store'}{\expr'}}{\sigma}$ and is read as ``the global environment is $\env$ and node $n$ performs a single reduction and updates its local environment to $\sigma$''.

Figure~\ref{fig:monadic-reductions} in the appendix shows the local reduction rules. Most of the rules verify some trust relationship between principals, written $\actsforquery{n; \env}{p}{q}{\level}$ and is read as ``node $n$ proves that $p$ acts for $q$ and uses delegations labeled up to $\level$ in the process''. We defer discussing this judgment until Section~\ref{subsec:deriving-trust}.

Rule \ruleref{E-Lift-Pure} lifts pure reductions to monadic reductions. Due to the structure of our evaluation contexts ($\ectx \hole ::= \ldots \mid \ectx \hole ; \overline{\expr}$) an expression can reduce at the top of the expression stack only. This is why pure reductions are defined only for single expressions, while the monadic reductions work over lists of expressions. Rules \ruleref{E-Get-Label} and \ruleref{E-Get-Clearance} returns the current label or clearance of the node that is evaluating the expression. Rule \ruleref{E-App} applies a function to an argument and labels the resulting value with the given principal. This choice may seem strange: Why deviate from the traditional semantics of function application? The answer is that with this approach we can combine local function calls and RPC into the same typing rule, which simplifies the calculus and its proofs. However, it is straightforward to extend the language with different syntactic constructions for local function application. It is straightforward to apply syntactic sugar that always unlabels the returned value in case of local function applications.

Rules \ruleref{E-New}, \ruleref{E-Read}, \ruleref{E-Write}, \ruleref{E-Label} and \ruleref{E-Unlabel} are all equivalent to the ones presented in LIO \cite{SRMMlio}, but now also take into account the possible information-flows arising via deriving trust relationships \cite{Arden:2015:FA:2859845.2859998}. Rules \ruleref{E-ToLabeled-1} and \ruleref{E-ToLabeled-2} evaluate an expression $\expr$, but once $\expr$ is evaluated to a term $\val$, the current label is restored to its state before evaluation of $\expr$ began, and $\val$ is labeled with the given label. This presentation of $\tolabeledkw$ is different from the original LIO \cite{SRMMlio} by avoiding interleaving of small-step and big-step operations, which simplifies the proofs considerably.

Rules \ruleref{E-Acts-For-True} and \ruleref{E-Acts-For-False} query the trust relationship between two given principals. Rules \ruleref{E-With-Scope} and \ruleref{E-Reset-Scope} introduce and eliminate a fluid scope respectively. Rules \ruleref{E-With-Strategy} introduces a new strategy and evaluates an expression in the lexical scope of the new strategy. Rule \ruleref{E-Reset-Strategy} eliminates the strategy once the expression reduces to a term. Finally, \ruleref{E-Assume} adds a new delegation. The rule uses the operator $\voicekw$ defined in Section~\ref{sec:background} to ensure that the computational context has sufficient integrity to delegate trust on behalf of $q$.

Figure~\ref{fig:use-case-for-fluid-scope} demonstrates the usefulness of fluid scoping for delegations. $\mathsf{Alice}$ invokes a function on $\mathsf{Bob}$'s node that grants another function (given as an argument) the authority to read Bob's confidential information. In addition, Bob enforces the policy that the function is only called once. Due to the $\withscopekw$ construct, the additional authority is only given to the function passed as an argument. Any other function will not be able to read Bob's confidential information.

\begin{figure}
\centering
\begin{lstlisting}
((*@$\lambda^{\mathsf{Alice}}_{\bot}$@*) _ . [...]
  let g = ((*@$\lambda^{\mathsf{Bob}}_{\bot}$@*) f .
              bref := new (*@$\integ{\mathsf{Bob}}$@*) true
              withScope (
                assume (*@$\conf{\mathsf{Alice}}$@*) (*@$\actsfor$@*) (*@$\conf{\mathsf{Bob}}$@*) @ (*@$\integ{\mathsf{Bob}}$@*)
                return ((*@$\lambda^{\mathsf{Alice}}_{\integ{\mathsf{Alice}}}$@*) x . 
                           b <- !bref
                           bref := false
                           if b then f x else false))) aliceCode
  in g bobSecret) ()
\end{lstlisting}
\caption{Bob grants a function supplied by Alice with authority to read Bob's confidential information once. }
\label{fig:use-case-for-fluid-scope}
\end{figure}

\paragraph{Global semantics}
A global configuration is a triple $\gconfig{n}{\env}{S}$ consisting of a node $n \in \Nameset$ denoting which node is currently reducing an expression, a global environment $\env$, and a mapping $S$ from names to local configurations. Figure~\ref{fig:global-steps} presents the reduction rules for global configurations. Rule \ruleref{G-Step-Local} lifts a local reduction to a global reduction, and rules \ruleref{G-Step-App} and \ruleref{G-Step-Ret} handle remote procedure calls and returns respectively. When node $n$ sends an RPC to node $m$, we call $n$ the source node and $m$ the target node. The global reduction rule is written as $\gconfig{n}{\env}{S} \gstepsto \gconfig{n'}{\env'}{S'}$ and can be read as ``node $n$ updates the environment $\env$ to $\env'$, updates the local configurations $S$ to $S'$, and transfers control to node $n'$''. We write the reflexive, transitive closure of $\gstepsto$ as $\gstepstos$.

We now explain how to model RPC. First, \ruleref{G-Step-App} transfers control to the target node, and the computation is wrapped in a $\tolabeledkw$ construct at the top of the execution stack on the target node to prevent the evaluation of the expression from raising the current label. Finally, the evaluation on source node is suspended. Second, Rule \ruleref{G-Step-Ret} returns control to a suspended source node when the top of the execution stack on the target node has reduced to a term.

The final rule, \ruleref{G-Step-Stop} halts the execution when the last node has reduced its expression to a term. We use the notation $\bullet(S)$ to mean $S = \config{\store}{\bullet}$ for some store $\store$.

Note that the computation is decentralized, and multiple nodes with different resources stored in their memories can cooperate and remote procedure calls interchangeably, but the semantics is still deterministic in that only one expression is reducible at any point. This determinism excludes internal timing leaks and other attacks usually found in concurrent systems \cite{Smith:1998:SIF:268946.268975, Muller:2012:TPS:2384616.2384621}, while still allowing multiple nodes to share computation.

\begin{figure}
\centering
\begin{mathpar}
\inferrule[G-Step-Local]{\step{n; \env}{S_n}{s}{\sigma}}{\gconfig{n}{\env}{S} \gstepsto \gconfig{n}{\extend{\env}{n}{\sigma}}{\extend{S}{n}{s}}}
\and
\inferrule[G-Step-App]{\level_n = \env_n.\lblkw \and \level_m = \env_m.\lblkw \and S_m = \config{\store_m}{\overline{\expr_m}} \\\\ \nopostflowstoquery{m; \env}{\level_n \join \level_m}{\conf{m}} \and S_n = \config{\store_n}{\efill{\app{(\abs{m}{\lb{p}{\type}}{x}{\expr_n})}{\expr_n'}}} \\\\ s_n' = \config{\store_n}{\efill{\wait{m}[\type]}} \and \env_m' = \extend{\env_m}{\lblkw}{\level_n \join \level_m} \\\\ s_m' = \config{\store_m}{(\internalTolabeled{\level_m}{p}{(\expr_n[\expr_n' / x])}) ; \overline{\expr_m}}}{\gconfig{n}{\env}{S} \gstepsto \gconfig{m}{\extend{\env}{m}{\env_m'}}{\extends{S}{n \mapsto S_n', m \mapsto s_m'}}}
\and
\inferrule[G-Step-Ret]{S_n = \config{\store_n}{\efill{\wait{m}[\type]}} \and S_m = \config{\store_m}{\val ; \overline{\expr_m}} }{\gconfig{m}{\env}{S} \gstepsto \gconfig{n}{\env}{\extends{S}{n \mapsto \config{\store_n}{\efill{\val}}, m \mapsto \config{\store_m}{\overline{\expr_m}}}}}
\and
\inferrule[G-Step-Stop]{\forall n \in \Nameset \setminus \{m\}~.~ \termsym(S_n) \and S_m = \config{\store_m}{\val ; \termsym}}{\gconfig{m}{\env}{S} \gstepsto[][] \gconfig{m}{\env}{\extend{S}{m}{\config{\store_m}{\termsym}}}}
\end{mathpar}
\caption{Semantics of global steps}
\label{fig:global-steps}
\end{figure}

\subsection{Deriving trust relationship in \lang}\label{subsec:deriving-trust}
\begin{figure}
    \centering
    \begin{mathpar}
    \inferrule[Bot]{}{\actsforquery{C}{p}{\bot}{\botinfoflow}}
    \and
    \inferrule[Top]{}{\actsforquery{C}{\top}{p}{\botinfoflow}}
    \and
    \inferrule[Refl]{}{\actsforquery{C}{p}{p}{\botinfoflow}}
    \and
    \inferrule[Hyp]{(p \actsfor q) \in \Assumps}{\actsforquery{C}{p}{q}{\botinfoflow}}
    \and
    \inferrule[Proj]{\actsforquery{C}{p}{q}{\level}}{\actsforquery{C}{\authproj{p}}{\authproj{q}}{\level}}
    \and
    \inferrule[ProjR]{}{\actsforquery{C}{p}{\authproj{p}}{\botinfoflow}}
    \and
    \inferrule[Own-1]{\actsforquery{C}{o}{o'}{\level_1} \\\\ \actsforquery{C}{p}{p'}{\level_2}}{\actsforquery{C}{\owner{o}{p}}{\owner{o'}{p'}}{\level_1 \join \level_2}}
    \and
    \inferrule[Own-2]{\actsforquery{C}{o}{o'}{\level_1} \\\\ \actsforquery{C}{p}{\owner{o'}{p'}}{\level_2}}{\actsforquery{C}{\owner{o}{p}}{\owner{o'}{p'}}{\level_1 \join \level_2}}
    \and
    \inferrule[Conj-L]{j \in \{ 1, 2 \} \\\\ \actsforquery{C}{p_j}{p}{\level}}{\actsforquery{C}{p_1 \conj p_2}{p}{\level}}
    \and
    \inferrule[Conj-R]{\actsforquery{C}{p}{p_1}{\level_1} \\\\\ \actsforquery{C}{p}{p_2}{\level_2}}{\actsforquery{C}{p}{p_1 \conj p_2}{\level_1 \join \level_2}}
    \and
    \inferrule[Disj-L]{\actsforquery{C}{p_1}{p}{\level_1} \\\\\ \actsforquery{C}{p_2}{p}{\level_2}}{\actsforquery{C}{p_1 \disj p_2}{p}{\level_1 \join \level_2}}
    \and
    \inferrule[Disj-R]{j \in \{ 1, 2 \} \\\\ \actsforquery{C}{p}{p_j}{\level}}{\actsforquery{C}{p}{p_1 \disj p_2}{\level}}
    \and
    \inferrule[Trans]{\actsforquery{C}{p}{q}{\level_1} \\\\ \actsforquery{C}{q}{r}{\level_2}}{\actsforquery{C}{p}{r}{\level_1 \join \level_2}}
    \and
    \inferrule[Del]{\mathsf{ss} = \env_n . \strategy \\\\ \actsforquerysmany{\Assumps; n; \env}{\mathsf{ss}}{p}{q}{\level} \\\\ \notactsforquery{\Assumps; n; \extend{\env}{n}{\env_n^\varepsilon}}{p}{q}{\level}}{\actsforquery{\Assumps; n; \env}{p}{q}{\level}}
    \and
    \inferrule[Fwd]{\mathsf{ss} = \env_n.\strategy \and \flowstoquery{\Assumps; n; \env}{\env_n . \lblkw}{\conf{m}}{\level_1} \\\\ \actsforquery{\Assumps; m; \extend{\env}{m}{\env_m^{\mathsf{ss}}}}{p}{q}{\level_2} }{\actsforquery{\Assumps; n; \env}{p}{q}{\level_1 \join \level_2}}
    \end{mathpar}
    \caption{Acts for judgment of \lang. The meta-variable $C$ abbreviates $\Assumps; n; \env$.}
    \label{fig:act-for-judgment}
\end{figure}

\lang{} allows, in the style of FLAM, the trust relationship between principals to be changed and queried dynamically throughout the evaluation of a program. We show how the ideas from FLAM on how to provide guarantees of confidentiality and integrity can be incorporated into the floating-label model of LIO. Figure~\ref{fig:act-for-judgment} shows how the judgment $\actsforquery{\Assumps; n; \env}{p}{q}{\level}$ derives trust relationships between principals. Intuitively $\actsforquery{\Assumps; n; \env}{p}{q}{\level}$ means that node $n$ has to raise its current floating label to be at least $\level$ in order to use the information that $q$ trusts $p$, assuming hypotheses $\Assumps \subseteq \mathcal{P} \times \mathcal{P}$ and global environment $\env$. We write $\actsforquery{n; \env}{p}{q}{\level}$ to mean $\actsforquery{\varnothing; n; \env}{p}{q}{\level}$. That is, the judgment holds with no hypotheses.

Many rules translate directly from FLAM, except for (1) using delegations and (2) querying remote nodes for trust relationships. This discrepancy is because the upper bound on the label of usable delegations in FLAM is given as ``input'' to the judgment, while in \lang{} the upper bound is part of the ``output'' of the judgment.\footnote{That the upper bound on the delegation labels is an ``input'' to the judgment can be seen in the $F\lambda$ calculus \cite{flamtr} where delegation labels appear in the surface syntax of expressions.}

Rule \ruleref{Bot} says that the element $\bot$ trusts any principal, and that deriving this trust requires information up to level $\botinfoflow$. Dually, \ruleref{Top} states that any principal trusts $\top$, and \ruleref{Refl} states that any element trusts itself. Rule \ruleref{Hyp} states that any hypothesis can be used to derive trust without raising the current label any further. This use of assumptions is an instance of a checked endorsement \cite{Chong:2007:SWA:1294261.1294265, DBLP:journals/corr/abs-1107-5594}, and is discussed later in this section. Rule \ruleref{Proj} expresses that applying projections preserve trust between principals and \ruleref{ProjR} states that a principal is at least as trusted as the projected principal. Rules \ruleref{Own-1} and \ruleref{Own-2} derives trust between ownership projections. First, \ruleref{Own-1} shows that trust between principals imply trust between owned principals, and \ruleref{Own-2} states that, if an ownership projection $\owner{o'}{p'}$ trusts a principal $p$ then another ownership principal $\owner{o}{p}$ also trusts $\owner{o'}{p'}$, but only if the the owner $o'$ trusts $o$. Rules \ruleref{Conj-L}, \ruleref{Conj-R}, \ruleref{Disj-L}, and \ruleref{Disj-R} correspond to the usual lattice rules for joins and meets, and \ruleref{Trans} ensures that the trust relation is transitive. Rule \ruleref{Fwd} expresses how a node $n$ can query another node $m$ for a trust relationship, but only if $n$ allows the information that caused $n$ to contact $m$ to be learned by $m$. We write $\sigma^{\mathsf{ss}}$ for the local environment $\extend{\sigma}{\strategy}{\mathsf{ss}}$. That is, the local environment $\sigma$ with strategy $\mathsf{ss}$. When node $n$ forwards the query to $m$, the search strategy used by $n$ is also used by $m$, as local reasoning about trust relationship queries would be impossible without knowing the strategies of every node in the system.

Finally, rule \ruleref{Del} expresses how delegations can be used to derive trust. The judgment uses the search strategy $\mathit{ss}$ to control how the information-flow lattice is searched: If $\mathit{ss} = \lbrack s_1, \dots, s_n \rbrack$ delegations with labels that flow to $s_1$ are unlabeled. If the query cannot be satisfied using only delegations whose label flow to $s_1$, delegations that flow to $s_2$ are unlabeled. This process continues until either the query is proven, or every principal in the strategy is used. The rule also ensures that the trust could not be derived without using a delegation. This ensures that the current label is not needlessly raised during trust checking. In practice, checking that the trust cannot be derived without using delegations amounts to only applying the \ruleref{Del} rule when the other rules fail to prove the trust relationship.

\begin{figure}
    \centering
    \begin{mathpar}
    \inferrule[Del-1]{\lb{\level}{p \actsfor q} \in \env.\scope \\\\ \flowstoquery{\Assumps, p \actsfor q; n; \env}{\level}{s}{\level'} \and \flowstoquery{\Assumps, p \actsfor q; n; \env}{\level'}{s}{\botinfoflow}}{\actsforquerysmany{\Assumps; n; \env}{\mathsf{s}::\mathsf{ss}}{p}{q}{s}}
    \and
    \inferrule[Del-2]{\actsforquerysmany{\Assumps; n; \env}{\mathsf{ss}}{p}{q}{\level'} \\\\
    {\begin{matrix}
\lb{\level}{p \actsfor q} \in \env.\scope \implies \forall \level'. & \notflowstoquery{\Assumps, p \actsfor q; n; \env}{\level}{s}{\level'} \, \vee \\
\multicolumn{2}{l}{(\flowstoquery{\Assumps, p \actsfor q; n; \env}{\level}{s}{\level'} \wedge \notflowstoquery{\Assumps, p \actsfor q; n; \env}{\level'}{s}{\botinfoflow})}
\end{matrix}}
    }{\actsforquerysmany{\Assumps; n; \env}{\cons{\mathsf{s}}{\mathsf{ss}}}{p}{q}{\level' \join s}}
    \end{mathpar}
    \caption{Auxiliary judgment for using delegations when proving an acts for query in \lang.}
    \label{fig:act-for-judgment-del}
\end{figure}

Figure~\ref{fig:act-for-judgment-del} formalizes this idea, where the first element $s$ in the strategy $\mathit{ss}$ that successfully derives the trust relationship terminates the proof search. Rule \ruleref{Del-1} terminates the proof search if a delegation that proves the query is found, as long as the delegation label can be proven to flow to the strategy principal. Note that this might require further use of delegations, and thus an additional check needs to be performed to verify that the information used is less than the strategy. This checking could potentially continue ad infinitum, so we apply a pragmatic approach and require this check not to use any delegations labeled higher than $\botinfoflow$. Section~\ref{sec:case-studies} motivates this decision, which shows several interesting examples that can all be implemented using this simplified checking mechanism.

Rule~\ruleref{Del-2} checks that the label of all delegations with the same body as the goal either (1) cannot be proven to flow to the strategy or (2) can be proven to flow to the strategy, but not without using delegations whose label does not flow to the strategy.

When checking if a delegation can be used in rules~\ruleref{Del-1} and \ruleref{Del-2} the hypotheses set $\Assumps$ is extended to include the trust relationship that is being checked. This usage of hypotheses is a form of checked endorsement which was also noted to be a useful extension to the Jif programming language \cite{Chong:2007:SWA:1294261.1294265}.
To see the effect of this style of reasoning, consider the query $\flowstoquery{n; \env}{p}{q}{\level}$ where $\env_n = (\botinfoflow, \scope, \lbrack q \rbrack)$ and $\scope = \{\lb{p}{(\conf{q} \conj \integ{p} \actsfor \conf{p} \conj \integ{q})} \}$. This query is equivalent to $\actsforquery{n; \env}{\conf{q} \conj \integ{p}}{\conf{p} \conj \integ{q}}{\level}$, so applying \ruleref{Del} and \ruleref{Del-1} the goal reduces to proving $\flowstoquery{p \flowsto q; n; \env}{p}{q}{\level'}$ for some $\level'$, which (ignoring the hypothesis) is the exact same query we started out with! However, we now have the hypothesis $p \flowsto q$, and the goal follows by applying \ruleref{Hyp}.

If no assumption was added when checking that the label on the delegation $\lb{p}{p \flowsto q}$ flows to the strategy principal $q$, this trust relationship could not be proven in any finite derivation. While this situation might appear synthetic, Section~\ref{sec:case-studies} will demonstrate a less synthetic use case where this problem shows up.

We end this section with an example of a query that morally should hold, but which cannot be justified using our trust judgment. Given the following four delegation sets:
\begin{align*}
\scope_1 &= \{ \lb{\botinfoflow}{a \actsfor b} \} \\
\scope_2 &= \{ \lb{c}{a \actsfor b}, \lb{\botinfoflow}{c \flowsto \level} \} \\
\scope_3 &= \{ \lb{c}{a \actsfor b}, \lb{d}{c \flowsto \level}, \lb{\botinfoflow}{d \flowsto \level} \} \\
\scope_4 &= \{ \lb{c}{a \actsfor b}, \lb{d}{c \flowsto \level}, \lb{e}{d \flowsto \level}, \lb{\botinfoflow}{e \flowsto \level} \}
\end{align*}
and the environments $\env_i = (\conf{\bot}, \scope_i, \lbrack \level \rbrack)$, the query $\actsforquery{n; \env}{a}{b}{\level}$ holds for $i \in \{1, 2, 3\}$, but does not hold for $i = 4$. To see why, consider proving the query using \ruleref{Del}. We must prove
\begin{equation*}
\actsforquerysmany{n; \env_4}{\lbrack d \rbrack}{a}{b}{\lbrack \level \rbrack}
\end{equation*}
using \ruleref{Del-1} the goal reduces to showing
\begin{align}
\label{eq:abc-in-del} &\lb{c}{a \actsfor b} \in \scope_4\\
\label{eq:c-flowsto-l-at-d} &\flowstoquery{\{a \actsfor b\}; n; \env_4}{c}{\level}{d}\\
\label{eq:d-flowsto-l-at-bot} &\flowstoquery{\{a \actsfor b\}; n; \env_4}{d}{\level}{\botinfoflow}
\end{align}
Condition \eqref{eq:abc-in-del} holds by definition of $\scope_4$, and \eqref{eq:c-flowsto-l-at-d} holds by applying rules \ruleref{Del} and \ruleref{Del-1}. But \eqref{eq:d-flowsto-l-at-bot} does not hold: we can only show $\flowstoquery{\{a \actsfor b\}; n; \env_4}{d}{\level}{e}$ and $\flowstoquery{\{a \actsfor b\}; n; \env_4}{e}{\level}{\botinfoflow}$, but this does not imply \eqref{eq:d-flowsto-l-at-bot}. That is, \lang{} cannot prove that the label on the information ``the label on the required delegation flows to the current strategy element'' is $\botinfoflow$. We have not found realistic case where this scenario presents a problem, and we leave the lifting of this restriction as future work.

\subsection{A type system for \lang.}
Since \lang{} controls information-flows via dynamic checks, the type system for \lang{} is straightforward. We write $\hastype{n; \tenv}{\expr}{\type}$ when expression $\expr$ can be given type $\type$ in a global type environment $\tenv: \Nameset \to (\Var \partialto \type)$ on node $n$. Figure~\ref{fig:type-judgment} shows excerpts of this judgment. Rule \ruleref{T-Principal} states that principals have type $\labeltype$, and \ruleref{T-Var} states that variable types are given by the global type environment $\tenv$. Rule \ruleref{T-Ref} simplifies the statement of Theorem~\ref{thm:preservation} by having the typing environment denote the type of both variables and locations. We say a location $\addr$ belongs to node $n$ if $\addr \in \dom(\tenv_n)$. Rule \ruleref{T-Abs} states that an abstraction has a function type and that, the typing environment for node $m$ is used when checking the type of the body, where $m$ is the target node. Rule \ruleref{T-Lab} states that labeled expressions have labeled types. Rules \ruleref{T-Lio}, \ruleref{T-Return} and \ruleref{T-Bind} are standard typing rules for monadic expressions. Rules \ruleref{T-New} states that, when a reference is allocated on a node $n$ the type of the location returned will belong to $n$. Rule \ruleref{T-Read} states that a reference can only be read on a node to which the location belongs. Finally, \ruleref{T-Wait} states that the type attached to a waiting expression is the type of the expression. The rules \ruleref{T-Wait} and \ruleref{T-Abs} are closely connected in that an RPC will evaluate an application to a waiting expression, so the typing rules for these expressions should match.

\paragraph{Store typing}
Given a global typing environment $\tenv$ we write $\wf{n; \tenv}{\store}$ if, for all $\addr$ such that $\store(\addr) = \lb{p}{\expr}$ and $\tenv_n(\addr) = \reftype[n]{\type}$ it holds that $\hastype{n; \tenv}{\expr}{\type}$. We write $\hastype{n; \tenv}{\config{\store}{\overline{\expr}}}{\overline{\type}}$ if $\wf{n; \tenv}{\store}$ and $\hastype{n; \tenv}{\expr_i}{\type_i}$ for $i = 1, \dots, n$ and $\overline{\expr} = \expr_1 \cdots \expr_n$ and $\overline{\type} = \type_1 \dots \type_n$. We lift this definition to global configurations and write $\hastype[m]{\tenv}{\gconfig{n}{\env}{S}}{\overline{\type}}$ if for all $n' \in \Nameset$ there exists a type $\overline{\type}'$ such that $\hastype{n'; \tenv}{S_{n'}}{\overline{\type}'}$, and furthermore, when $n' = m$ we have $\overline{\type}' = \overline{\type}$.

\paragraph{Preservation}
As the program allocates references during evaluation, the typing environment needs to incorporate these locations accordingly. Thus Theorem~\ref{thm:preservation} shows that, if a configuration is well-typed and takes a single step, there exists a global typing environment, which is an extension of the old typing environment, such that the new configuration is well-typed.

\begin{theorem}[Preservation]\label{thm:preservation}
If $\hastype[m]{\tenv}{\gconfig{n}{\env}{S}}{\overline{\type}}$ and $\gconfig{n}{\env}{S} \gstepsto \gconfig{n'}{\env'}{S'}$ then there exists $\tenv' \supseteq \tenv$ and $\overline{\type}'$ such that either $\overline{\type}' \leq \overline{\type}$ or $\overline{\type} \leq \overline{\type}'$ and $\hastype[m]{\tenv'}{\gconfig{n'}{\env'}{S'}}{\overline{\type}'}$.
\end{theorem}

We write $\overline{\type_1} \leq \overline{\type_2}$ to mean that $\overline{\type_1}$ is a \emph{prefix} of $\overline{\type_2}$. So Theorem~\ref{thm:preservation} states that the global reduction semantics steps to a global configuration typeable with either a prefix or a suffix of the original type. The statement in the technical report~\cite{techreport} is stronger: It proves that $\overline{\type}' \leq \overline{\type}$ when $\gconfig{n}{\env}{S} \gstepsto \gconfig{n'}{\env'}{S'}$ is an application of \ruleref{G-Step-Ret} and $\overline{\type} \leq \overline{\type}'$ when $\gconfig{n}{\env}{S} \gstepsto \gconfig{n'}{\env'}{S'}$ is an application of \ruleref{G-Step-App}, and $\overline{\type} = \overline{\type}'$ otherwise.

\begin{figure}
\centering
\begin{mathpar}
\inferrule[T-Principal]{~}{\hastype{n; \tenv}{p}{\labeltype}}
\and
\inferrule[T-Var]{\tenv_n(x) = \type}{\hastype{n; \tenv}{x}{\type}}
\and
\inferrule[T-Ref]{\tenv_n(\addr) = \reftype[n]{\type}}{\hastype{n; \tenv}{\addr}{\reftype[n]{\type}}}
\and
\inferrule[T-Abs]{\hastype{m; \tenv, x : \type_1}{\expr}{\liotype{\type_2}} \\\\ \type = \func{\type_1}{\liotype{(\labeled{\type_2})}}}{\hastype{n; \tenv}{\abs{m}{\lb{p}{\type_2}}{x}{\expr}}{\type}}
\and
\inferrule[T-Lab]{\hastype{n; \tenv}{\expr_2}{\type} \\\\ \hastype{n; \tenv}{\expr_1}{\labeltype}}{\hastype{n; \tenv}{\lb{\expr_1}{\expr_2}}{\labeled{\type}}}
\and
\inferrule[T-Lio]{\hastype{n; \tenv}{\expr}{\type}}{\hastype{n; \tenv}{\lio{\expr}}{\liotype{\type}}}
\and
\inferrule[T-Return]{\hastype{n; \tenv}{\expr}{\type}}{\hastype{n; \tenv}{\return{\expr}}{\liotype{\type}}}
\and
\inferrule[T-Bind]{\hastype{n; \tenv}{\expr_1}{\liotype{\type_1}} \\\\ \hastype{n; \tenv}{\expr_2}{\func{\type_1}{\liotype{\type_2}}}}{\hastype{n; \tenv}{\bind{\expr_1}{\expr_2}}{\liotype{\type_2}}}
\and
\inferrule[T-New]{\hastype{n; \tenv}{\expr_1}{\labeltype} \\\\ \hastype{n; \tenv}{\expr_2}{\type} \\\\ \type' = \liotype{(\reftype[n]{\type})}}{\hastype{n; \tenv}{\new{\expr_1}{\expr_2}}{\type'}}
\and
\inferrule[T-Read]{\hastype{n; \tenv}{\expr}{\reftype[n]{\type}}}{\hastype{n; \tenv}{\readref{\expr}}{\liotype{\type}}}
\and
\inferrule[T-Wait]{\type' = \liotype{(\labeled{\type})}}{\hastype{n; \tenv}{\wait{m}[\type]}{\type'}}
\end{mathpar}
\caption{Typing judgment for \lang.}
\label{fig:type-judgment}
\end{figure}