This section introduces a formalization of the \lang{} language. We first introduce the syntax and semantics of the language and afterward present the judgment for deriving trust between principals in the language. Finally, this section presents a type system for \lang. 

\subsection{Syntax}
Figure~\ref{fig:language-syntax} shows the syntax of \lang. The meta-variable $\val$ ranges over values, which include boolean literals, the unit value, runtime representations of principals, locations and variables, abstractions $\abs{n}{\lb{p}{\type}}{x}{\expr}$ (which are parameterized over the node $n$ on which to evaluate the expression $\expr$, and the principal $p$ representing the label on the value returned from invoking the abstraction, and $\type$, the type of $\expr$). We will to omit the type annotation on abstractions in examples. Finally, the language includes lists using $\nil$ and $\consop$ (pronounced \emph{cons}) to express strategies.

Expressions are ranged over by the meta-variable $\expr$ and include terms, applications, projections, elimination of booleans and lists, recursive functions, monadic expressions using $\returnkw$ and $\bindop$, allocation, reading and writing of references. Following LIO, the language supports operations for labeling and unlabeling expressions, and the operation $\tolabeledkw$ for controlling label-creep. The operations $\getlabel$ and $\getclearance$ returns the current label and clearance of the computational context respectively, and $\labelofkw$ returns the label of a labeled value.
%The scope of delegations is \emph{fluid} \cite{Moore:2016:EAC:2983990.2984021} and the operation $\withscopekw$ creates a new fluid scope. Traditionally, the scope of a variable binding describes the spatial and temporal part of the program in which the variable is visible. Following \cite{Moore:2016:EAC:2983990.2984021} we call the spatial aspect of scoping the \emph{scope}, and the temporal aspect of scoping the \emph{extent}. Dynamic scoping often refers to scoping that has dynamic extent and ``indefinite'' scope, while fluid scoping is scoping that has dynamic extend and lexical scoping.
The operation $\withscope{\expr}$ creates a new scope for delegations. The scoping for delegations have dynamic extent \cite{Moore:2016:EAC:2983990.2984021}, i.e., the delegation will be visible during the evaluation of $\expr$. However, unlike traditional dynamic scoping, the delegation is removed once the evaluation of $\expr$ terminates. This ensures safe and correct use of delegations. \TODO{I tried to merge your comments about the ``alternative text'' and ``not mention fluid scoping''. }

Strategies are introduced using the $\withstrategy{\expr_{\mathsf{strat}}}{\expr}$ operation, which introduces a new strategy $\expr_{\mathsf{strat}}$ for the evaluation of $\expr$. Similar to scoping of delegations, strategies have dynamic extent, and the current strategy can be obtained using $\getstrategy$. Finally, delegations can be added and trust relationships can be queried. The shaded regions describe syntax that is not part of the surface language, but rather constructs used during evaluation. We explain these constructs as we describe the evaluation rules for expressions in Section~\ref{sec:semantics}.

%: expression $\wait{n}[\type]$ waits for node $n$ to respond from an RPC call returning a value of type $\type$, and $\internalTolabeled{p}{q}{\expr}$ performs a toLabeled-computation and resets the current label to $p$ afterwards. The remaining constructs are used to reset parts of the state after computations inside $\withstrategykw$ and $\withscopekw$ evaluates to values. \TODO{I don't like actually explaining the syntax not part of the surface language in this section, but reviewer $C$ really wants this right away. What do you think?}

Finally, types are ranged over by the meta-variable $\type$ and include standard types like the boolean type; the unit type; as well as function-, list- and product types. Non-standard types include the type of FLAM principals ($\labeltype$), the type of labeled values ($\labeled{\type}$), the type of LIO computations $\liotype{\type}$, as well as location-aware reference types $\reftype[n]{\type}$. The location $n$ refers to the node on which the reference has been allocated.

\begin{figure}
    \centering
    \begin{tabular}{l}
         $\begin{aligned}[t]
         \val &::= \true \mid \false \mid () \mid p \mid \addr \mid x \mid \abs{n}{\lb{p}{\type}}{x}{\expr} \mid (\expr, \expr) \mid \cons{\expr}{\expr} \\
         &\quad \mid \nil \mid \graybox{\lb{p}{\expr} \mid \lio{\expr}}
         \end{aligned}$ \\
         $\begin{aligned}[t]
         \expr &::= \val \mid \app{\expr}{\expr} \mid \proj{i}{\expr} \mid \ifexpr{\expr}{\expr}{\expr} \mid \case{\expr}{\expr}{\expr} \mid \fix{\expr} \\ &\quad \mid \return{\expr} \mid \bind{\expr}{\expr} \mid
         \new{\expr}{\expr} \mid \readref{\expr} \mid \writeref{\expr}{\expr} \mid \Label{\expr}{\expr} \\ &\quad
         \mid \unlabel{\expr} \mid
         \tolabeled{\expr}{\expr} \mid \getlabel \mid \getclearance \\ &\quad
         \mid \labelof{\expr} \mid \withscope{\expr} \mid \expr \actsfor \expr \mid \withstrategy{\expr}{\expr} \\ &\quad \mid \adddelegate{\expr}{\expr}{\expr} \mid \getstrategy
         \mid \graybox{\wait{n}[\type]} \\ &\quad
         \mid \graybox{\internalTolabeled{p}{q}{\expr} \mid \resetstrategy{\overline{p}}{\expr} \mid \resetscope{\scope}{\expr}}
         \end{aligned}$ \\
         $\begin{aligned}[t]
         \type &::= \bool \mid \unit \mid \func{\type}{\type} \mid \listtype{\type} \mid \pair{\type}{\type} \mid \labeltype \mid \labeled{\type} \\ &\quad
         \mid \liotype{\type} \mid \reftype[n]{\type}
         \end{aligned}$
    \end{tabular}
    \caption{The \lang{} language}
    \label{fig:language-syntax}
\end{figure}

\subsection{Semantics}\label{sec:semantics}
The semantics of \lang{} can be split into two judgments: Local reduction rules, which evaluate an expression on a specific node; and global reduction rules, which models remote procedure calls (RPC) and returns. We first present the local reduction rules.

\paragraph{Local semantics}
The semantics of local reduction rules is given by a structured operational semantics with evaluation contexts \cite{Felleisen:1988:TPF:73560.73576}. We elide the definition of the evaluation context, as this is mostly standard.

We further split the local reduction rules into two categories: Pure reduction rules $\steppure{\expr}{\expr'}$ which reduces expressions independently of the store and of which node is evaluating the expression. The pure reduction rules are given in Figure~\ref{fig:pure-reductions}. Pure reductions include injecting terms into monadic contexts, monadically binding terms, recursive applications, projecting pairs, eliminating booleans and lists and obtaining the label of a labeled value.

\begin{figure}
    \centering
    \begin{mathpar}
    \inferrule{}{\steppure{\efill{\return{\val}}} {\efill{\lio{\val}}}}
    \and
    \inferrule{}{\steppure{\efill{\bind{\lio{\val}}{\expr}}}{\efill{\app{\expr}{\val}}}}
    \and
    \inferrule{}{\steppure{\efill{\fix{\expr}}}{\efill{\app{\expr}{(\fix{\expr})}}}}
    \and
    \inferrule{}{\steppure{\efill{\proj{i}{(\expr_1, \expr_2)}}}{\efill{\expr_i}}}
    \and
    \inferrule{}{\steppure{\efill{\ifexpr{b}{\expr_{\true}}{\expr_{\false}}}}{\efill{\expr_b}}}
    \and
    \inferrule{}{\steppure{\efill{\case{\nil}{\expr_1}{\expr_2}}}{\efill{\expr_1}}}
    \and
    \inferrule{}{\steppure{\efill{\case{(\cons{\expr_\hd}{\expr_\tl})}{\expr_1}{\expr_2}}}{ \efill{\app{\app{\expr_2}{\expr_\hd}}{\expr_\tl}}}}
    \and
    \inferrule{}{\steppure{\efill{\labelof{(\lb{p}{\expr})}}}{\efill{p}}}
    \and
    \inferrule{\steppure{\expr}{ \expr'}}{\steppure{\efill{\expr}}{\efill{\expr'}}}
    \end{mathpar}
    \caption{Pure reductions for \lang.}
    \label{fig:pure-reductions}
\end{figure}

The remaining local reductions all depend either on the store or on the identity of the node that evaluates the expression. We denote these as \emph{monadic reductions}.

Before introducing the monadic small-step local reduction, we introduce the remaining necessary concepts: First, a store $\store: \Loc \partialto \val$ is a partial mapping from locations to terms, and we write the empty store as $\varnothing$. A local configuration is a pair $\config{\store}{\overline{\expr}}$ consisting of a store $\store$ and a stack of expressions $\overline{\expr}$. We use stacks of expressions to handle incoming remote procedure calls which ``interrupts'' the current computation to evaluate the RPC. A global environment $\env: \Nameset \to \sigma$ is a mapping from names to local environments $\sigma$. A local environment $(\lblkw, \scope, \strategy)$ contains the current label ($\lblkw$), the set of delegations local to the node ($\scope$) and the current strategy of the node ($\strategy$). We use record notation for these and write $\sigma.\lblkw$, $\sigma.\scope$ and $\sigma.\strategy$ respectively. We let $\emptyenv$ denote the initial global environment satisfying $\emptyenv(n) = (\conf{\bot} \conj \integ{n}, \nodelegations, \nil)$. That is, the initial global environment maps all names to an initial local environment with a current label $\conf{\bot} \conj \integ{n}$, the empty set of delegations $\nodelegations$ and the empty strategy.

The monadic small-step relation is written $\step{n; \env}{\config{\store}{\expr}}{\config{\store'}{\expr'}}{\sigma}$ and is read as ``the global environment is $\env$ and node $n$ performs a single reduction and updates its local environment to $\sigma$''. Figure~\ref{fig:monadic-reductions} in the appendix shows the local reduction rules. Many of the rules verify some trust relationship between principals, written $\actsforquery{n; \env}{p}{q}{\level}$ and is read as ``node $n$ proves that $p$ acts for $q$ and uses delegations labeled up to $\level$ in the process''. We discuss this judgment in Section~\ref{subsec:deriving-trust}.

Rule \ruleref{E-Lift-Pure} lifts pure reductions to monadic reductions. Only the expression at the top of the expression stack can reduce. Rules \ruleref{E-Get-Label} and \ruleref{E-Get-Clearance} return respectively, the current label or clearance of the node that is evaluating the expression. Rule \ruleref{E-App} applies a function to an argument and labels the resulting value with the given principal $p$. Labeling the result of function applications allows us to combine local function application and RPC into the same typing rule, which simplifies the calculus and its proofs. However, it is straightforward to have different syntactic constructions for local and remote function application.

Rules \ruleref{E-New}, \ruleref{E-Read}, \ruleref{E-Write}, \ruleref{E-Label} and \ruleref{E-Unlabel} are all equivalent to the ones presented in LIO \cite{SRMMlio}, but now also take into account the possible information-flows arising via deriving trust relationships \cite{Arden:2015:FA:2859845.2859998}. Rule \ruleref{E-ToLabeled-1} saves the current label $\env_n.\lblkw$, and evaluates $\expr$ using the \ruleref{E-Ctx}. Once $\expr$ has evaluated to a value \ruleref{E-ToLabeled-2} restores the current label and labels the value with the given label $q$. This presentation of $\tolabeledkw$ is different from the original formulation of LIO \cite{SRMMlio} and avoids interleaving small-step and big-step operations.

%Rules \ruleref{E-ToLabeled-1} and \ruleref{E-ToLabeled-2} evaluate an expression $\expr$, but once $\expr$ is evaluated to a term $\val$, the current label is restored to its state before evaluation of $\expr$ began, and $\val$ is labeled with the given label. This presentation of $\tolabeledkw$ is different from the original formulation of LIO \cite{SRMMlio} and avoids interleaving small-step and big-step operations.

Rules \ruleref{E-Acts-For-True} and \ruleref{E-Acts-For-False} query the trust relationship between two given principals using the trust judgment, which we will explain in Section~\ref{subsec:deriving-trust}. The result depends on which delegations are in scope, and the current strategy. A new scope for delegations is created using \ruleref{E-With-Scope} which evaluates an expression $\expr$ in a new scope, and once $\expr$ has reduced to a value, rule \ruleref{E-Reset-Scope} eliminates the scope. Similarly, rule \ruleref{E-With-Strategy} introduces a new strategy and evaluates an expression in the scope of the new strategy. Once the expression has reduced to a value, rule \ruleref{E-Reset-Strategy} eliminates the strategy. Finally, \ruleref{E-Assume} adds a new delegation. The rule uses the operator $\voicekw$ defined in Section~\ref{sec:background} to ensure that the computational context has sufficient integrity to delegate trust on behalf of $q$.

\input{Sections/local-reduction-rules.tex}

Figure~\ref{fig:use-case-for-fluid-scope} demonstrates the usefulness of delegation scoping with dynamic extent: On line~2, $\mathsf{Alice}$ invokes a function on $\mathsf{Bob}$'s node that, on line~5, grants another function (given as an argument) the authority to read Bob's confidential information. In addition, on line~9, Bob enforces the policy that the function is only called once. Due to the use of $\withscopekw$ on line~4, the additional authority is given only to the function passed as an argument and only when it is invoked at that point. Any other function will not be able to read Bob's confidential information.

\begin{figure}
\centering
\begin{lstlisting}
((*@$\lambda^{\mathsf{Alice}}_{\bot}$@*) _ . [...]
  let g = ((*@$\lambda^{\mathsf{Bob}}_{\bot}$@*) f . do
              bref := new (*@$\integ{\mathsf{Bob}}$@*) true
              withScope (do
                assume (*@$\conf{\mathsf{Alice}}$@*) (*@$\actsfor$@*) (*@$\conf{\mathsf{Bob}}$@*) @ (*@$\integ{\mathsf{Bob}}$@*)
                return ((*@$\lambda^{\mathsf{Alice}}_{\integ{\mathsf{Alice}}}$@*) x . do
                           b <- !bref
                           bref := false
                           if b then f x else false)))
                             aliceCode
  in g bobSecret) ()
\end{lstlisting}
\caption{Bob grants a function supplied by Alice with authority to read Bob's confidential information once. }
\label{fig:use-case-for-fluid-scope}
\end{figure}

\paragraph{Global semantics}
A global configuration is a triple $\gconfig{n}{\env}{S}$ consisting of a node $n \in \Nameset$ denoting which node will reduce next, a global environment $\env$, and a mapping $S$ from nodes to local configurations. Figure~\ref{fig:global-steps} presents the reduction rules for global configurations. Rule \ruleref{G-Step-Local} lifts a local reduction to a global reduction, and rules \ruleref{G-Step-App} and \ruleref{G-Step-Ret} handle remote procedure calls and returns respectively. When node $n$ sends an RPC to node $m$, we call $n$ the source node and $m$ the target node. The global reduction rule is written as $\gconfig{n}{\env}{S} \gstepsto \gconfig{n'}{\env'}{S'}$ and can be read as ``node $n$ updates the environment $\env$ to $\env'$, updates the local configurations $S$ to $S'$, and transfers control to node $n'$''. We write the reflexive, transitive closure of $\gstepsto$ as $\gstepstos$.

We now explain how to express RPC. Rule \ruleref{G-Step-App} transfers control to the target node, and the computation is wrapped in a $\tolabeledkw$ construct at the top of the execution stack on the target node to prevent the evaluation of the expression from raising the current label.
The rule ensures that $m$'s new current label $\level_n \join \level_m$, flows to $m$'s clearance label $\conf{m}$. This ensures that the clearance always upper bounds the current label.
Finally, the evaluation on the source node is suspended. Second, Rule \ruleref{G-Step-Ret} returns control to a suspended source node when the top of the execution stack on the target node has reduced to a term.

%The final rule, \ruleref{G-Step-Stop} halts the execution when the last node has reduced its expression to a term. We use the notation $\bullet(S)$ to mean $S = \config{\store}{\bullet}$ for some store $\store$.

Note that the computation is decentralized, and multiple nodes with different resources stored in their memories can cooperate and invoke remote procedure calls interchangeably, but the semantics is still deterministic in that only one expression is reducible at any point. Determinism excludes internal timing leaks and other attacks usually found in concurrent systems \cite{Smith:1998:SIF:268946.268975, Muller:2012:TPS:2384616.2384621}, while still allowing multiple nodes to share computation.

\begin{figure}
\centering
\begin{mathpar}
\inferrule[G-Step-Local]{\step{n; \env}{S_n}{s}{\sigma}}{\gconfig{n}{\env}{S} \gstepsto \gconfig{n}{\extend{\env}{n}{\sigma}}{\extend{S}{n}{s}}}
\and
\inferrule[G-Step-App]{\level_n = \env_n.\lblkw \and \level_m = \env_m.\lblkw \and S_m = \config{\store_m}{\overline{\expr_m}} \\\\ \nopostflowstoquery{m; \env}{\level_n \join \level_m}{\conf{m}} \and S_n = \config{\store_n}{\efill{\app{(\abs{m}{\lb{p}{\type}}{x}{\expr_n})}{\expr_n'}}} \\\\ s_n' = \config{\store_n}{\efill{\wait{m}[\type]}} \and \sigma_m' = \extend{\env_m}{\lblkw}{\level_n \join \level_m} \\\\ s_m' = \config{\store_m}{(\internalTolabeled{\level_m}{p}{(\expr_n[\expr_n' / x])}) ; \overline{\expr_m}}}{\gconfig{n}{\env}{S} \gstepsto \gconfig{m}{\extend{\env}{m}{\sigma_m'}}{\extends{S}{n \mapsto s_n', m \mapsto s_m'}}}
\and
\inferrule[G-Step-Ret]{S_n = \config{\store_n}{\efill{\wait{m}[\type]}} \and S_m = \config{\store_m}{\val ; \overline{\expr_m}} }{\gconfig{m}{\env}{S} \gstepsto \gconfig{n}{\env}{\extends{S}{n \mapsto \config{\store_n}{\efill{\val}}, m \mapsto \config{\store_m}{\overline{\expr_m}}}}}
%\and
%\inferrule[G-Step-Stop]{\forall n \in \Nameset \setminus \{m\}~.~ \termsym(S_n) \and S_m = \config{\store_m}{\val ; \termsym}}{\gconfig{m}{\env}{S} \gstepsto[][] \gconfig{m}{\env}{\extend{S}{m}{\config{\store_m}{\termsym}}}}
\end{mathpar}
\caption{Semantics of global steps}
\label{fig:global-steps}
\end{figure}

\subsection{Deriving trust relationship in \lang}\label{subsec:deriving-trust}
\begin{figure}
    \centering
    \begin{mathpar}
    \inferrule[Bot]{}{\actsforquery{C}[\option{\stratelem}]{p}{\bot}{\botinfoflow}}
    \and
    \inferrule[Top]{}{\actsforquery{C}[\option{\stratelem}]{\top}{p}{\botinfoflow}}
    \and
    \inferrule[Refl]{}{\actsforquery{C}[\option{\stratelem}]{p}{p}{\botinfoflow}}
    \and
    \inferrule[Hyp]{(p \actsfor q) \in \Assumps}{\actsforquery{C}[\option{\stratelem}]{p}{q}{\botinfoflow}}
    \and
    \inferrule[Proj]{\actsforquery{C}[\option{\stratelem}]{p}{q}{\level}}{\actsforquery{C}[\option{\stratelem}]{\authproj{p}}{\authproj{q}}{\level}}
    \and
    \inferrule[ProjR]{}{\actsforquery{C}[\option{\stratelem}]{p}{\authproj{p}}{\botinfoflow}}
    \and
    \inferrule[Own-1]{\actsforquery{C}[\option{\stratelem}]{o}{o'}{\level_1} \\\\ \actsforquery{C}[\option{\stratelem}]{p}{p'}{\level_2}}{\actsforquery{C}[\option{\stratelem}]{\owner{o}{p}}{\owner{o'}{p'}}{\level_1 \join \level_2}}
    \and
    \inferrule[Own-2]{\actsforquery{C}[\option{\stratelem}]{o}{o'}{\level_1} \\\\ \actsforquery{C}[\option{\stratelem}]{p}{\owner{o'}{p'}}{\level_2}}{\actsforquery{C}[\option{\stratelem}]{\owner{o}{p}}{\owner{o'}{p'}}{\level_1 \join \level_2}}
    \and
    \inferrule[Conj-L]{j \in \{ 1, 2 \} \\\\ \actsforquery{C}[\option{\stratelem}]{p_j}{p}{\level}}{\actsforquery{C}[\option{\stratelem}]{p_1 \conj p_2}{p}{\level}}
    \and
    \inferrule[Conj-R]{\actsforquery{C}[\option{\stratelem}]{p}{p_1}{\level_1} \\\\\ \actsforquery{C}[\option{\stratelem}]{p}{p_2}{\level_2}}{\actsforquery{C}[\option{\stratelem}]{p}{p_1 \conj p_2}{\level_1 \join \level_2}}
    \and
    \inferrule[Disj-L]{\actsforquery{C}[\option{\stratelem}]{p_1}{p}{\level_1} \\\\\ \actsforquery{C}[\option{\stratelem}]{p_2}{p}{\level_2}}{\actsforquery{C}[\option{\stratelem}]{p_1 \disj p_2}{p}{\level_1 \join \level_2}}
    \and
    \inferrule[Disj-R]{j \in \{ 1, 2 \} \\\\ \actsforquery{C}[\option{\stratelem}]{p}{p_j}{\level}}{\actsforquery{C}[\option{\stratelem}]{p}{p_1 \disj p_2}{\level}}
    \and
    \inferrule[Trans]{\actsforquery{C}[\option{\stratelem}]{p}{q}{\level_1} \\\\ \actsforquery{C}[\option{\stratelem}]{q}{r}{\level_2}}{\actsforquery{C}[\option{\stratelem}]{p}{r}{\level_1 \join \level_2}}
    \and
    \inferrule[Del]{\lb{\level}{p \actsfor q} \in \env_n.\scope \\\\ \flowstoquery{\Assumps, p \actsfor q; n; \env}{\level}{s}{\level'} \\\\ \flowstoquery{\Assumps, p \actsfor q; n; \env}{\level'}{s}{\botinfoflow} \\\\ \forall \level''~.~\notactsforquery{\Assumps; n; \env}[\!\!\none]{\,p}{q}{\level''}}{\actsforquery{\Assumps; n; \env}[\stratelem]{p}{q}{\level}}
    \and
    \inferrule[Fwd]{\level_n = \env_n.\lblkw \and \sigma_m = \extends{\env_m}{\lblkw \mapsto \level_n \join \level_m} \\\\ \level_m = \env_m.\lblkw \and \flowstoquery{\Assumps; n; \env}{\level_n \join \level_m}{\conf{m}}{\level_1} \\\\ \actsforquery{\Assumps; m; \extend{\env}{m}{\sigma_m}}[\option{\stratelem}]{p}{q}{\level_2} }{\actsforquery{\Assumps; n; \env}[\option{\stratelem}]{p}{q}{\level_1 \join \level_2}}
    \end{mathpar}
    \caption{Acts for judgment of \lang. The meta-variable $C$ abbreviates $\Assumps; n; \env$.}
    \label{fig:act-for-judgment}
\end{figure}

\lang{} allows, in the style of FLAM, the trust relationship between principals to be changed and queried dynamically throughout the evaluation of a program. We show how the ideas from FLAM on how to provide guarantees of confidentiality and integrity can be incorporated into the floating-label model of LIO. Figure~\ref{fig:act-for-judgment} shows how the judgment $\actsforquery{\Assumps; n; \env}[\option{\stratelem}]{p}{q}{\level}$ derives trust relationships between principals. Ignoring the optional strategy element $\option{\stratelem}$, the judgment means that node $n$ proves that that $q$ trusts $p$ in the global environment $\env$ using delegations with labels that are upper bounded by $\level$, and assuming that $r$ acts for $s$ for all $(r, s) \in \Assumps$. The optional strategy element $\option{\stratelem}$ is either the element $\stratelem$, or nothing, which we write as $\none$. We write $\actsforquery{n; \env}[\option{\stratelem}]{p}{q}{\level}$ to mean $\actsforquery{\varnothing; n; \env}[\option{\stratelem}]{p}{q}{\level}$. That is, the judgment holds with no hypotheses. We also write $\actsforquery{\Assumps; n; \env}[\option{\stratelem}]{p}{q}{}$ to mean $\exists \level~.~\actsforquery{\Assumps; n; \env}[\option{\stratelem}]{p}{q}{\level}$. Finally, guided by \eqref{eq:flam-flowsto-from-actsfor} we write $\flowstoquery{\Assumps; n; \env}[\option{\stratelem}]{p}{q}{\level}$ to mean $\actsforquery{\Assumps; n; \env}[\option{\stratelem}]{\conf{q} \conj \integ{p}}{\conf{p} \conj \integ{q}}{\level}$ and use similar abbreviations as above.

Many rules translate directly from FLAM, except for using delegations and querying remote nodes for trust relationships. This discrepancy is because the upper bound on the label of usable delegations in FLAM is given as ``input'' to the judgment, while in \lang{} the upper bound is part of the ``output'' of the judgment.\footnote{That the upper bound on the delegation labels is an ``input'' to the judgment can be seen in the $F\lambda$ calculus \cite{flamtr} where delegation labels appear in the surface syntax of expressions.} This relieves the programmer from manually annotating trust queries, and operations performing trust queries, with explicit upper bounds on the labels of delegations.

%Rule \ruleref{Bot} says that principal $\bot$ trusts any principal, and that deriving this trust requires information up to level $\botinfoflow$.
%Dually, \ruleref{Top} states that any principal trusts $\top$, and \ruleref{Refl} states that any principal trusts itself.
Rule \ruleref{Hyp} states that any hypothesis can be used to derive trust without raising the current label any further. This use of hypotheses is an instance of a checked endorsement \cite{Chong:2007:SWA:1294261.1294265, DBLP:journals/corr/abs-1107-5594}, and is discussed later in this section.
%Rule \ruleref{Proj} expresses that applying projections preserve trust between principals and \ruleref{ProjR} states that a principal is at least as trusted as the projected principal.
Rules \ruleref{Own-1} and \ruleref{Own-2} derives trust between ownership projections. First, \ruleref{Own-1} shows that trust between principals imply trust between owned principals, and \ruleref{Own-2} states that, if an ownership projection $\owner{o'}{p'}$ trusts a principal $p$ and owner $o'$ trusts $o$ then another ownership principal $\owner{o}{p}$ also trusts $\owner{o'}{p'}$.
%Rules \ruleref{Conj-L}, \ruleref{Conj-R}, \ruleref{Disj-L}, and \ruleref{Disj-R} correspond to the usual lattice rules for joins and meets, and \ruleref{Trans} ensures that the trust relation is transitive.
Rule \ruleref{Fwd} expresses how a node $n$ can query another node $m$ for a trust relationship, but only if $n$ allows the information that caused $n$ to contact $m$ to be learned by $m$ (i.e., $\level_n \flowsto \conf{m}$, which is implied by the premise $\level_n \join \level_m \flowsto \conf{m}$). Furthermore, when forwarding a query, node $m$ must raise its current label to $\level_n \join \level_m$ to propagate the sensitivity of the computational context of node $n$. Finally, when node $n$ forwards the query to $m$, the optional strategy element used by $n$ is also used by $m$ as otherwise, local reasoning about trust relationship queries would be impossible without knowing the strategies of every node in the system.

Finally, rule \ruleref{Del} expresses how delegations is used to derive trust. First, a delegation that proves the trust relationship must be present ($\lb{\level}{p \actsfor q} \in \env_n.\scope$), then, the label on the delegation must flow to the strategy element $\stratelem$ that is currently bounding how much the current label can be raised ($\flowstoquery{\Assumps, p \actsfor q; n; \env}{\level}{s}{\level'}$). But the fact that $\level$ is bounded by $\stratelem$ could also be used to leak information, so $\level'$ should also be bounded by $\stratelem$. This checking could potentially continue ad infinitum, so we apply a pragmatic approach and require this check not to use any delegations labeled higher than $\botinfoflow$. Section~\ref{sec:case-studies} motivates this decision, which shows several interesting examples that can all be implemented using this simplified checking mechanism.
% TODO: Look into Elisavet Kozyri's upcoming work on label chains. I think this is related.

When checking if a delegation can be used in the rule \ruleref{Del}, the hypotheses set $\Assumps$ is extended to include the trust relationship that is being checked. This usage of hypotheses is a form of checked endorsement which was also noted to be a useful extension to the Jif programming language \cite{Chong:2007:SWA:1294261.1294265}.
To see the effect of this style of reasoning, consider the query $\flowstoquery{n; \env}{p}{q}{\level}$ where $\env_n = (\integ{n}, \scope, \lbrack q \rbrack)$ and $\scope = \{\lb{p}{(\conf{q} \conj \integ{p} \actsfor \conf{p} \conj \integ{q})} \}$. This query is equivalent to $\actsforquery{n; \env}{\conf{q} \conj \integ{p}}{\conf{p} \conj \integ{q}}{\level}$, so applying \ruleref{Del} the goal reduces to proving $\flowstoquery{p \flowsto q; n; \env}{p}{q}{\level'}$ for some $\level'$, which (ignoring the hypothesis) is the exact same query we started out with! However, we now have the hypothesis $p \flowsto q$, and the goal follows by applying \ruleref{Hyp}. If no hypothesis was added when checking that the label on the delegation $\lb{p}{p \flowsto q}$ flows to the strategy principal $q$, this trust relationship could not be proven in any finite derivation. While this situation might appear synthetic, Section~\ref{sec:case-studies} will demonstrate a less synthetic use case where this problem shows up.

The rule also ensures that the trust could not be derived without using a delegation ($\forall \level''. \notactsforquery{\Assumps; n; \env}[\!\!\none]{\,p}{q}{\level''}$). This ensures that the current label is not needlessly raised during trust checking. In practice, checking that the trust cannot be derived without using delegations amounts to only applying the \ruleref{Del} rule when the other rules fail to prove the trust relationship. Note that \ruleref{Del} requires a strategy element $\stratelem$, instead of the optional element $\option{\stratelem}$ found on the other rules: it does not make sense to apply the \ruleref{Del} rule without a strategy element.

Rule~\ruleref{Acts-For} in Figure~\ref{fig:act-for-judgment-del} is the top-level judgment for deriving trust, which iterates through the strategy elements in the current strategy and attempts to prove the trust relationship. Rule~\ruleref{Acts-For-Cons-1} states that, once a strategy element $\stratelem$ proves the trust, the query succeeds, and \ruleref{Acts-For-Cons-2} states that, if a strategy element cannot prove the trust relationship ($\forall \level'.~ \notactsforquery{C}[\!\!\stratelem]{\,p}{q}{\level'}$), the search continues with the tail $\stratelem*$ of the strategy. Finally, if the strategy is $\nil$, no strategy element is used, which prevents the use of the \ruleref{Del} rule. Since no application \ruleref{Del} is possible, no delegations will be unlabeled and so the trust is derived without raising the current label.

\begin{figure}
    \centering
    \begin{mathpar}
    \inferrule[Acts-For-Cons-1]{\actsforquery{C}[\stratelem]{p}{q}{\level}}{\actsforquery{C}[\cons{\stratelem}{\stratelem*}]{p}{q}{\level}}
    \and
    \inferrule[Acts-For-Cons-2]{\forall \level'~.~ \notactsforquery{C}[\!\!\stratelem]{\,p}{q}{\level'} \\\\ \actsforquery{C}[\stratelem*]{p}{q}{\level}}{\actsforquery{C}[\cons{\stratelem}{\stratelem*}]{p}{q}{\stratelem \join \level}}
    \and
    \inferrule[Acts-For-Nil]{\actsforquery{C}[\none]{p}{q}{\botinfoflow}}{\actsforquery{C}[\nil]{p}{q}{\botinfoflow}}
    \and
    \inferrule[Acts-For]{\stratelem* = \env_n.\strategy \and \actsforquery{C}[\stratelem*]{p}{q}{\level}}{\actsforquery{C}{p}{q}{\level}}
    \end{mathpar}
    \caption{Auxiliary judgment for using delegations when proving an acts for query in \lang.}
    \label{fig:act-for-judgment-del}
\end{figure}

We end this section with an example of a query that morally should hold, but which cannot be justified using our trust judgment. Given the following four delegation sets:
\begin{align*}
\scope_1 &= \{ \lb{\botinfoflow}{a \actsfor b} \} \\
\scope_2 &= \{ \lb{c}{a \actsfor b}, \lb{\botinfoflow}{c \flowsto \level} \} \\
\scope_3 &= \{ \lb{c}{a \actsfor b}, \lb{d}{c \flowsto \level}, \lb{\botinfoflow}{d \flowsto \level} \} \\
\scope_4 &= \{ \lb{c}{a \actsfor b}, \lb{d}{c \flowsto \level}, \lb{e}{d \flowsto \level}, \lb{\botinfoflow}{e \flowsto \level} \}
\end{align*}
and the environments $\env_i = (\integ{n}, \scope_i, \lbrack \level \rbrack)$, the query $\actsforquery{n; \env}{a}{b}{\level}$ holds for $i \in \{1, 2, 3\}$, but does not hold for $i = 4$. To see why, consider proving the query using \ruleref{Del}. We must prove that
\begin{align}
\label{eq:abc-in-del} &\lb{c}{a \actsfor b} \in \scope_4\\
\label{eq:c-flowsto-l-at-d} &\flowstoquery{\{a \actsfor b\}; n; \env_4}[\level]{c}{\level}{d}\\
\label{eq:d-flowsto-l-at-bot} &\flowstoquery{\{a \actsfor b\}; n; \env_4}[\level]{d}{\level}{\botinfoflow}
\end{align}
Condition \eqref{eq:abc-in-del} holds by definition of $\scope_4$, and \eqref{eq:c-flowsto-l-at-d} holds by applying \ruleref{Del}. But \eqref{eq:d-flowsto-l-at-bot} does not hold: we can only show $\flowstoquery{\{a \actsfor b\}; n; \env_4}{d}{\level}{e}$ and $\flowstoquery{\{a \actsfor b\}; n; \env_4}{e}{\level}{\botinfoflow}$, but this does not imply \eqref{eq:d-flowsto-l-at-bot}. That is, \lang{} cannot prove that the label on the information ``the label on the required delegation flows to the current strategy element'' is $\botinfoflow$. We have not found a realistic case where this scenario presents a problem, and we leave lifting this restriction as future work.

\subsection{A type system for \lang.}
Since \lang{} controls information-flows via dynamic checks, the type system for \lang{} is straightforward. We write $\hastype{n; \tenv}{\expr}{\type}$ when expression $\expr$ can be given type $\type$ in a global type environment $\tenv: \Nameset \to (\Var \uplus \Loc \partialto \type)$ on node $n$. Note that the typing environment maps both variables and locations to types. Figure~\ref{fig:type-judgment} shows excerpts of this judgment.
%Rule \ruleref{T-Principal} states that principals have type $\labeltype$, and \ruleref{T-Var} states that variable types are given by the global type environment $\tenv$.
%Rule \ruleref{T-Ref} simplifies the statement of Theorem~\ref{thm:preservation} by having the typing environment denote the type of both variables and locations.
Rule \ruleref{T-Abs} states that a function has a function type and that, the typing environment for node $m$ is used when checking the type of the body, where $m$ is the target node. Rule \ruleref{T-Lab} states that labeled expressions have labeled types. Rules \ruleref{T-Return} and \ruleref{T-Bind} are standard typing rules for monadic expressions. Rule \ruleref{T-To-Labeled} states that a $\tolabeled{\expr_1}{\expr_2}$ expression is well-typed when $\expr_1$ is a principal, and that the expression has type $\labeled{\type}$ if $\expr_2$ has type $\type$.
We say a location $\addr$ belongs to node $n$ if $\addr \in \dom(\tenv_n)$. Rule \ruleref{T-New} states that, when a reference is allocated on a node $n$ the type of the location returned will belong to $n$, and \ruleref{T-Read} states that a reference can only be read on a node to which the location belongs. Finally, \ruleref{T-Wait} states that the type attached to a waiting expression is the type of the expression.
%The rules \ruleref{T-Wait} and \ruleref{T-Abs} are closely connected in that an RPC will evaluate an application to a waiting expression, so the typing rules for these expressions should match.

Given a global typing environment $\tenv$ we write $\wf{n; \tenv}{\store}$ if, for all $\addr$ such that $\store(\addr) = \lb{p}{\expr}$ and $\tenv_n(\addr) = \reftype[n]{\type}$ it holds that $\hastype{n; \tenv}{\expr}{\type}$. We write $\hastype{n; \tenv}{\config{\store}{\overline{\expr}}}{\overline{\type}}$ if $\overline{\expr} = \expr_1 \cdots \expr_n$ and $\wf{n; \tenv}{\store}$ and $\hastype{n; \tenv}{\expr_i}{\type_i}$ for $i = 1, \dots, n$ and $\overline{\type} = \type_1 \dots \type_n$. We lift this definition to global configurations and write $\hastype[m]{\tenv}{\gconfig{n}{\env}{S}}{\overline{\type}}$ if for all $n' \in \Nameset$ there exists a type $\overline{\type}'$ such that $\hastype{n'; \tenv}{S_{n'}}{\overline{\type}'}$, and furthermore, when $n' = m$ we have $\overline{\type}' = \overline{\type}$.

%\paragraph{Preservation}
%As the program allocates references during evaluation, the typing environment needs to incorporate these locations accordingly. Thus Theorem~\ref{thm:preservation} shows that, if a configuration is well-typed and takes a single step, there exists a global typing environment, which is an extension of the old typing environment, such that the new configuration is well-typed.

%\begin{theorem}[Preservation]\label{thm:preservation}
%If $\hastype[m]{\tenv}{\gconfig{n}{\env}{S}}{\overline{\type}}$ and $\gconfig{n}{\env}{S} \gstepsto \gconfig{n'}{\env'}{S'}$ then there exists $\tenv' \supseteq \tenv$ and $\overline{\type}'$ such that either $\overline{\type}' \leq \overline{\type}$ or $\overline{\type} \leq \overline{\type}'$ and $\hastype[m]{\tenv'}{\gconfig{n'}{\env'}{S'}}{\overline{\type}'}$.
%\end{theorem}

%We write $\overline{\type_1} \leq \overline{\type_2}$ to mean that $\overline{\type_1}$ is a \emph{prefix} of $\overline{\type_2}$. So Theorem~\ref{thm:preservation} states that the global reduction semantics steps to a global configuration typeable with either a prefix or a suffix of the original type. The statement in the technical report~\cite{techreport} is stronger: It proves that $\overline{\type}' \leq \overline{\type}$ when $\gconfig{n}{\env}{S} \gstepsto \gconfig{n'}{\env'}{S'}$ is an application of \ruleref{G-Step-Ret} and $\overline{\type} \leq \overline{\type}'$ when $\gconfig{n}{\env}{S} \gstepsto \gconfig{n'}{\env'}{S'}$ is an application of \ruleref{G-Step-App}, and $\overline{\type} = \overline{\type}'$ otherwise.

\begin{figure}
\centering
\begin{mathpar}
\inferrule[T-Principal]{~}{\hastype{n; \tenv}{p}{\labeltype}}
\and
\inferrule[T-Var]{\tenv_n(x) = \type}{\hastype{n; \tenv}{x}{\type}}
\and
\inferrule[T-Ref]{\tenv_n(\addr) = \reftype[n]{\type}}{\hastype{n; \tenv}{\addr}{\reftype[n]{\type}}}
\and
\inferrule[T-Abs]{\hastype{m; \tenv, x : \type_1}{\expr}{\liotype{\type_2}} \\\\ \type = \func{\type_1}{\liotype{(\labeled{\type_2})}}}{\hastype{n; \tenv}{\abs{m}{\lb{p}{\type_2}}{x}{\expr}}{\type}}
\and
\inferrule[T-Lab]{\hastype{n; \tenv}{\expr_2}{\type} \\\\ \hastype{n; \tenv}{\expr_1}{\labeltype}}{\hastype{n; \tenv}{\lb{\expr_1}{\expr_2}}{\labeled{\type}}}
\and
\inferrule[T-Return]{\hastype{n; \tenv}{\expr}{\type}}{\hastype{n; \tenv}{\return{\expr}}{\liotype{\type}}}
\and
\inferrule[T-Bind]{\hastype{n; \tenv}{\expr_1}{\liotype{\type_1}} \\\\ \hastype{n; \tenv}{\expr_2}{\func{\type_1}{\liotype{\type_2}}}}{\hastype{n; \tenv}{\bind{\expr_1}{\expr_2}}{\liotype{\type_2}}}
\and
\inferrule[T-To-Labeled]{\hastype{n; \tenv}{\expr_1}{\labeltype} \\\\ \hastype{n; \tenv}{\expr_2}{\liotype{\type}} \\\\ \type' = \liotype{(\labeled{\type})}}{\hastype{n; \tenv}{\tolabeled{\expr_1}{\expr_2}}{\type'}}
\and
\inferrule[T-Read]{\hastype{n; \tenv}{\expr}{\reftype[n]{\type}}}{\hastype{n; \tenv}{\readref{\expr}}{\liotype{\type}}}
\and
\inferrule[T-New]{\hastype{n; \tenv}{\expr_1}{\labeltype} \\\\ \hastype{n; \tenv}{\expr_2}{\type} \\\\ \type' = \liotype{(\reftype[n]{\type})}}{\hastype{n; \tenv}{\new{\expr_1}{\expr_2}}{\type'}}
\and
\inferrule[T-Wait]{\type' = \liotype{(\labeled{\type})}}{\hastype{n; \tenv}{\wait{m}[\type]}{\type'}}
\end{mathpar}
\caption{Typing judgment for \lang.}
\label{fig:type-judgment}
\end{figure}