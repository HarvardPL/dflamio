Before discussing how FLAM and LIO combines in a uniform way, we briefly introduce each system separately. We first highlight the important parts of FLAM, and details can be found in \cite{Arden:2015:FA:2859845.2859998}.

\subsection{The FLAM principal lattice}
Figure~\ref{fig:flam-syntax} describes the syntax of a FLAM principal. The grammar is parametric in a set $\Nameset$ of names representing principals like Alice and Bob. Given a principal $p$ FLAM gives the ability to talk about $p$'s confidentiality or integrity using \emph{basis projections} $\conf{p}$ and $\integ{p}$ respectively. This represents the authority to learn anything that $p$ can learn, or modify anything that $p$ can modify. Given principals $p$ and $q$ FLAM can also represent the authority of \emph{both} $p$ and $q$ as $p \conj q$ or the authority of \emph{either} $p$ or $q$ as $p \disj q$. This forms a lattice with the partial ordering $\actsfor$ (pronounced ``acts for''\footnote{Reading $p \actsfor q$ as ``$p$ acts for $q$'' can also be interpreted as ``$q$ trusts $p$'', which may sometimes be helpful for intuition.}) where $\bot$ and $\top$ represents the least and most trusted principals respectively, where the elements is the closure of $\Nameset \cup \{\bot, \top\}$ under the operations $\conj, \disj, \rightarrow$ and $\leftarrow$\footnote{Formally, the set of elements is the equivalence class of the closure modulo the relation $\equiv$ where $a \equiv b \iff a \actsfor b \wedge b \actsfor a$.}.

\begin{figure}[h]
    \centering
    \begin{tabular}{ll}
    $n \in \Nameset$ \\
    $p ::= \bot \mid \top \mid \name \mid p \conj p \mid p \disj p \mid \conf{p} \mid \integ{p} \mid \owner{p}{p}$
    \end{tabular}
    \caption{Syntax of FLAM}
    \label{fig:flam-syntax}
\end{figure}

\paragraph{Ownership projections}
Besides basis projections $\rightarrow$ and $\leftarrow$ FLAM also defines \emph{ownership projections} $\owner{p}{q}$ representing the principal $q$, but the owner $p$ controls which principals $\owner{p}{q}$ should trust. To see how ownership projections increase the expressiveness of FLAM, imagine we represent the fact that Bob is an employee at Acme by the delegation Bob $\actsfor$ Emp. Intuitively, this seems fine, but now Bob can add new employees by delegating to new principals. For instance if Alice $\actsfor$ Bob it follows by transitivity that Alice $\actsfor$ Emp! Instead, we represent the fact that Bob is an employee of Acme as $\owner{\text{Acme}}{\text{Bob}}$ $\actsfor$ Emp. Since Acme controls which principals $\owner{\text{Acme}}{\text{Bob}}$ delegate to Bob can no longer add employees by delegating to them.

\paragraph{An information-flow ordering}
An important distinction between FLAM and other authorization models is that FLAM unifies trust and information-flow into a single concept. Specifically, FLAM defines\footnote{FLAM also defines a meet operation, but we will not need this.}
\begin{align*}
p \flowsto q &\circeq \conf{q} \conj \integ{p} \actsfor \conf{p} \conj \integ{q}\\
p \join q &\circeq \conf{(p \conj q)} \conj \integ{(p \disj q)}
\end{align*}
and it can be shown that this forms a lattice with the partial ordering $\flowsto$ and the bottom element $\bot^{\flowsto} = \conf{\bot} \conj \integ{\top}$ representing the least confidential and most trusted principal, and the top element $\top^{\flowsto} = \conf{\top} \conj \integ{\bot}$ representing the most confidential and least trusted principal\footnote{Like for the lattice representing trust, the set of elements in the information-flow lattice is the equivalence classes modulo the relation $\equiv$ defined as $a \equiv b \iff a \flowsto b \wedge b \flowsto a$.}.

\subsection{Coarse-grained information flow using LIO.}
LIO \cite{SRMMlio} is a Haskell library for dynamic information-flow control. LIO takes a coarse-grained approach to information-flow and uses a \emph{floating label model}: Instead of attaching a label to each value in the program, the \emph{computational context} is labeled with a label called the current label. Throughout the execution of the program this label will ``climb'' up the information-flow lattice until it is required to climb above the \emph{clearance level} of the program. The type of LIO computations form a monad \cite{Wadler:1995:MFP:647698.734146}, which makes programming with LIO convenient in Haskell. Specifically, the two operations $\returnkw$ embeds a pure expression into the LIO computational context, and the operation $\bindop$ (pronounced ``bind'') chains together multiple LIO operations.

\paragraph{Labeled values}
As LIO protects every value in the computational context by a single label, it must provide a way to label some values with a higher than the current label (ie., a value representing a password should not be protected merely by the current label). To do this, LIO provieds several useful operations.

\BRAINDUMP{Introduce \cite{Arden:2015:FA:2859845.2859998} and \cite{SRMMlio}. Talk about the the syntax in Figure~\ref{fig:flam-syntax}}.

\TODO{Mention that we call a principal (name) a node if we are referring to the principals' machine. Mention that we write $\mathcal{P}$ for the closure set of $\Nameset \cup \{\top, \bot \}$ under the operations $\wedge$, $\vee$ and $\pi$. Also mention that we write $\bot^{\flowsto}$ for the bottom element of the lattice $(\mathcal{P}, \flowsto)$, which correspond to the least confidential and most trusted principal in the lattice. Also define voice.}