Before discussing how FLAM and LIO fit together, we briefly introduce each system separately. We first highlight the essential parts of FLAM necessary for this work, and details can be found in \cite{Arden:2015:FA:2859845.2859998}. Similarly, we highlight the essential parts of LIO, and additional details can be found in \cite{SRMMlio}.

\subsection{The FLAM principal lattice}
Figure~\ref{fig:flam-syntax} describes the syntax of FLAM principals. The grammar is parametric in a set $\Nameset$ of names representing principals like $\mathsf{Alice}$ and $\mathsf{Bob}$. Given a principal $p$ FLAM gives the ability to talk about the confidentiality and integrity of $p$ using \emph{basis projections} $\conf{p}$ and $\integ{p}$ respectively. The principal $\conf{p}$ represents the authority to learn anything that $p$ can learn, and $\integ{p}$ represents the authority to modify anything that $p$ can modify. Given principals $p$ and $q$ FLAM can also represent the authority of \emph{both} $p$ and $q$ as $p \conj q$ or the authority of \emph{either} $p$ or $q$ as $p \disj q$. This forms a lattice $(\mathcal{P}, \actsfor)$ with the partial order $\actsfor$ (pronounced \emph{acts for}), where $\bot$ and $\top$ represents the least and most trusted principals respectively, and where the elements are given by the grammar in Figure~\ref{fig:flam-syntax}. We denote the set of principals by $\mathcal{P}$.\footnote{Formally, the elements in the lattice is the equivalence class of $\mathcal{P}$ modulo the relation $\equiv$ where $a \equiv b \iff a \actsfor b$ and $b \actsfor a$.}.

Besides basis projections $\rightarrow$ and $\leftarrow$ FLAM also defines \emph{ownership projections} $\owner{p}{q}$ representing the principal $q$, but where the owner $p$ controls which principals $\owner{p}{q}$ should trust. We will use ownership extensively in the example presented in Section~\ref{subsec:agents}.

\begin{figure}
    \centering
    \begin{tabular}{ll}
    $n \in \Nameset$ \\
    $p ::= \bot \mid \top \mid \name \mid p \conj p \mid p \disj p \mid \conf{p} \mid \integ{p} \mid \owner{p}{p}$
    \end{tabular}
    \caption{Syntax of FLAM}
    \label{fig:flam-syntax}
\end{figure}


\paragraph{An information-flow ordering}
An important distinction between FLAM and other authorization models is that FLAM unifies trust and information-flow into a single concept. Specifically, FLAM defines the operations
\begin{align*}
p \flowsto q &\circeq \conf{q} \conj \integ{p} \actsfor \conf{p} \conj \integ{q}\\
p \join q &\circeq \conf{(p \conj q)} \conj \integ{(p \disj q)} \\
p \meet q &\circeq \conf{(p \disj q)} \conj \integ{(p \conj q)}
\end{align*}
That is, $p \flowsto q$ (pronounced $p$ \emph{flows to} $q$) if $q$ acts for the confidentiality of $p$, and $p$ acts for the integrity of $q$. The \emph{join} of $p$ and $q$, written $p \join q$ is defined as the principal with the authority of both $p$'s and $q$'s confidentiality, and the authority of either $p$'s or $q$'s integrity. The \emph{meet} of $p$ and $q$, written $p \meet q$ is defined dually as the confidentiality of either $p$ or $q$, and the integrity of both $p$ and $q$.
This forms a lattice $(\mathcal{P}, \flowsto)$ with the partial order $\flowsto$, where the bottom element $\botinfoflow \circeq \conf{\bot} \conj \integ{\top}$ represents the least confidential and most trusted principal, and the top element $\top^{\flowsto} \circeq \conf{\top} \conj \integ{\bot}$ represents the most confidential and least trusted principal\footnote{Once again, the elements is equivalence classes of $\mathcal{P}$ modulo the relation $\equiv$ defined as $a \equiv b \iff a \flowsto b$ and $b \flowsto a$.}.

\paragraph{Voice of a principal}
Finally, FLAM defines the \emph{voice} of a principal $p$, denoted $\voice{p}$, as the minimum integrity needed to influence the flow of information labeled $p$. Formally, the voice operation is defined for principals in normal form\footnote{In \cite{Arden:2015:FA:2859845.2859998} the authors show how any FLAM principal $p$ can be factored into a conjunction of a confidentiality projection $\conf{q}$ and an integrity projection $\integ{r}$. This is called the normal form of $p$.} $\conf{p} \conj \integ{q}$ as $\voice{\conf{p} \conj \integ{q}} = \integ{p} \conj \integ{q}$, and a principal $p$ \emph{speaks for} principal $q$ if $p \actsfor \voice{q}$.

\subsection{Coarse-grained information flow using LIO.}
LIO \cite{SRMMlio} is a Haskell library for dynamic information-flow control. LIO is parametric in the label model and takes a coarse-grained approach to information-flow using a \emph{floating label model}: Instead of attaching a label to each value in the program, the \emph{computational context} is protected with a single label called the \emph{current label}. Throughout the execution of the program the current label will ``float up'' the information-flow lattice as more confidential (or less trustworthy) information is brought into the computational context. The current label restricts what data can be modified, ensuring that public side effects do not depend on confidential information.

The type of LIO computations gives rise to a monad \cite{Wadler:1995:MFP:647698.734146} that encapsulates raising the current label and performing the necessary information-flow checks to ensure security. The monadic structure of LIO makes programming with it convenient in Haskell. Specifically, the operations $\return{\expr}$ embeds a pure expression $\expr$ into the LIO computational context, and the operation $\bind{\expr_1}{\expr_2}$ (pronounced \emph{bind}) chains together monadic LIO operations $\expr_1$ and $\expr_2$.

In addition to the current label, LIO also provides a \emph{clearance label}, imposing an upper bound on the current label. The clearance label gives LIO a form of access control by restricting which data can be observed and modified. For instance, if the clearance label of a program is \emph{Public} no \emph{Secret} information can be observed by the program, as the current label cannot float up to \emph{Secret}.

\paragraph{Labeled values}
In addition to protecting every value in the computational context by a single label $\level_{\mathsf{cur}}$, LIO also provide a way to protect single values with a label higher than $\level_{\mathsf{cur}}$. The type of labeled values of type \texttt{a} is written in Haskell as \mintinline{haskell}{Labeled l a}, where \texttt{l} is the type of labels.

Labeled values are useful if, for instance, the program needs to pass around a variable containing a secret password, but not need the \emph{value of the variable}.
To do this, LIO provides three operations:
\begin{minted}{haskell}
label :: Label l => a -> l -> LIO l (Labeled l a)
unlabel :: Label l => Labeled l a -> LIO l a
labelOf :: Label l => Labeled l a -> l
\end{minted}
Here, \mintinline{haskell}{Label l} is a typeclass constraint specifying that the type \texttt{l} must be an instance of the \mintinline{haskell}{Label} typeclass, meaning that \texttt{l} must have operations $\join$, $\meet$ and $\flowsto$. The operation \mintinline{haskell}{label} takes an expression $\expr$ and a label $\level$, and labels $\expr$ with the label $\level$. This labeled value can then be passed around without raising the label of the computational context. When the value is needed, the operation \mintinline{haskell}{unlabel} must be invoked, which gets back the value and raises the current label $\level_{\mathsf{cur}}$ to $\level_{\mathsf{cur}} \join \level$, while checking that the new current label flows to the clearance label $\level_{\mathsf{clr}}$ of the application.

Finally, \mintinline{haskell}{labelOf} extracts the label of a labeled value. Note that this operation does not return a value in the LIO monad. This implies that no information-flow checks are performed when invoking \mintinline{haskell}{labelOf}. In other words, the label of a labeled value is public information. This fact is important when we define trust checking using strategies in Section~\ref{subsec:deriving-trust}.

\paragraph{Preventing label creep}
As the program executes and confidential information enters the computational context through \mintinline{haskell}{unlabel} operations, the current label will continue to \emph{creep} upwards, restricting the possible side effects. To avoid unnecessary label creep LIO introduces the following operation:
\begin{minted}{haskell}
toLabeled :: Label l => l -> LIO l a ->
               LIO l (Labeled l a)
\end{minted}
Evaluating \mintinline{haskell}{toLabeled l e} when the current label is $\level_{\mathsf{cur}}$ will evaluate \texttt{e} and then reset the current label to $\level_{\mathsf{cur}}$. To remain secure, the result is labeled with the label \texttt{l}. Furthermore, LIO checks that the evaluation of \texttt{e} never raises the current label above \texttt{l}.